     1                                  %include "winapi.inc"
     1                              <1> STD_OUTPUT_HANDLE equ -11
     2                              <1> INVALID_HANDLE_VALUE equ -1
     2                                  
     3                                  extern GetStdHandle
     4                                  extern WriteFile
     5                                  
     6                                  global myprintf
     7                                  
     8                                  section .text
     9                                  ;
    10                                  
    11                                  ;---------------------------------------------------------------------------------
    12                                  ; Writes character (ASCII) to the console.
    13                                  ;
    14                                  ; Entry: al - character
    15                                  ; Note:  none.
    16                                  ; Exit:  none.
    17                                  ; Chngs: RAX R11
    18                                  ;---------------------------------------------------------------------------------
    19                                  ; TODO: переделать в реализацию putc, переименовать putc.
    20                                  write_char:
    21 00000000 8805(00000000)          		mov [rel .char], al
    22 00000006 51                      		push rcx
    23 00000007 52                      		push rdx
    24 00000008 4150                    		push r8
    25 0000000A 4151                    		push r9
    26 0000000C 4152                    		push r10
    27 0000000E 488B0D(01000000)        		mov rcx, [rel stdout_handle]
    28 00000015 488D15(00000000)        		lea rdx, [rel .char]
    29 0000001C 41B801000000            		mov r8, 1
    30 00000022 4D31C9                  		xor r9, r9
    31 00000025 6A00                    		push 0
    32 00000027 4883EC20                		sub rsp, 32
    33 0000002B E8(00000000)            		call WriteFile
    34 00000030 4883C420                		add rsp, 32
    35 00000034 4883C408                		add rsp, 8
    36 00000038 415A                    		pop r10
    37 0000003A 4159                    		pop r9
    38 0000003C 4158                    		pop r8
    39 0000003E 5A                      		pop rdx
    40 0000003F 59                      		pop rcx
    41                                  		
    42 00000040 C3                      		ret
    43                                  
    44                                  section .bss
    45 00000000 <res 00000001>          .char:  resb 1
    46                                  
    47                                  section .text
    48                                  mystrncpy:
    49 00000041 C3                      		ret
    50                                  
    51                                  section .text
    52                                  ;---------------------------------------------------------------------------------
    53                                  ; Converts unsigned integer to ASCII string in the specified base.
    54                                  ;
    55                                  ; Entry: RCX - number to be converted,
    56                                  ;        RDX - base,
    57                                  ;        R8 - output string (must be sufficient to hold the number converted).
    58                                  ; Note:  none.
    59                                  ; Exit:  none.
    60                                  ; Chngs: RCX R8 R9 R10
    61                                  ;---------------------------------------------------------------------------------
    62                                  ; void* itoa_unsigned(unsigned int input, char *buffer, int radix)
    63                                  ; TODO: optimize a little bit more.
    64                                  myitoa_unsigned:
    65                                  		;?push si
    66                                  
    67                                  		; UB if base if less than 2 or greater than 36
    68                                  		; cmp bx, 2
    69                                  		; jl @@invalid_base
    70                                  		; cmp bx, 36
    71                                  		; jg @@invalid_base
    72                                  		
    73                                  		;?push di
    74                                  		
    75 00000042 4885C0                  		test rax, rax
    76 00000045 7470                    		jz .number_is_zero
    77                                  		
    78 00000047 4150                    		push r8
    79                                  
    80 00000049 4889D0                  		mov rax, rdx
    81 0000004C 48FFC8                  		dec rax
    82 0000004F 4885D0                  		test rax, rdx
    83                                  		
    84 00000052 7425                    		jz .power_of_2
    85                                  		
    86 00000054 4889C8                  		mov rax, rcx
    87 00000057 4989D1                  		mov r9, rdx                              ; R9 - base
    88                                  
    89                                  ; General base
    90                                  .general_base_loop:
    91 0000005A 4885C0                  		test rax, rax
    92 0000005D 744A                    		jz .loop_end
    93                                  		
    94 0000005F 4831D2                  		xor rdx, rdx
    95 00000062 49F7F1                  		div r9                                   ; RAX - quotient, RDX - remainder
    96                                  		
    97 00000065 4C8D15(00000000)        		lea r10, [rel .char_table]
    98 0000006C 490FB61412              		movzx rdx, byte [r10 + rdx]
    99                                  		
   100 00000071 418810                  		mov [r8], dl
   101 00000074 49FFC0                  		inc r8
   102                                  		
   103 00000077 EBE1                    		jmp .general_base_loop
   104                                  
   105                                  .power_of_2:
   106 00000079 4989D1                  		mov r9, rdx
   107 0000007C 49FFC9                  		dec r9                                   ; R9 - mask of last bits
   108 0000007F F3480FBCD2              		tzcnt rdx, rdx                           ; Equivalent of __builtin_ctz() in asm
   109                                  		                                         ; similar to __builtin_popcnt() and popcnt.
   110 00000084 4887CA                  		xchg rcx, rdx                            ; shr works only for cl as the second operand.
   111                                  .power_of_2_loop:
   112 00000087 4885D2                  		test rdx, rdx
   113 0000008A 741D                    		jz .loop_end
   114                                  		
   115 0000008C 4889D0                  		mov rax, rdx
   116 0000008F 4C21C8                  		and rax, r9
   117                                  		
   118 00000092 4C8D15(00000000)        		lea r10, [rel .char_table]
   119 00000099 4D0FB61402              		movzx r10, byte [r10 + rax]
   120                                  		
   121 0000009E 458810                  		mov [r8], r10b
   122 000000A1 49FFC0                  		inc r8
   123                                  		
   124 000000A4 48D3EA                  		shr rdx, cl
   125                                  		
   126 000000A7 EBDE                    		jmp .power_of_2_loop
   127                                  		
   128                                  .loop_end:
   129                                  
   130 000000A9 41C60000                		mov [r8], byte 0
   131                                  		
   132 000000AD 4C89C2                  		mov rdx, r8
   133 000000B0 59                      		pop rcx 
   134 000000B1 E80D000000              		call reverse_string
   135                                  
   136 000000B6 C3                      		ret
   137                                  
   138                                  .number_is_zero:
   139 000000B7 41C60030                		mov [r8], byte '0'		
   140 000000BB 49FFC0                  		inc r8
   141                                  		
   142 000000BE 41C60000                		mov [r8], byte 0
   143                                  
   144 000000C2 C3                      		ret
   145                                  
   146                                  ;@@invalid_base:
   147                                  ;		pop di
   148                                  ;		ret
   149                                  
   150                                  section .rdata
   151                                  .char_table:
   152 00000000 303132333435363738-     	db '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'
   152 00000009 39                 
   153 0000000A 414243444546474849-     	db 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'
   153 00000013 4A                 
   154 00000014 4B4C4D4E4F50515253-     	db 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T'
   154 0000001D 54                 
   155 0000001E 55565758595A            	db 'U', 'V', 'W', 'X', 'Y', 'Z'
   156                                  
   157                                  section .text
   158                                  ; Entry: RCX - start of the string
   159                                  ;        RDX - address of the zero byte in the string
   160                                  ;
   161                                  reverse_string:
   162 000000C3 48FFCA                  		dec rdx
   163                                  .loop:
   164 000000C6 4839D1                  		cmp rcx, rdx
   165 000000C9 7310                    		jae .loop_end
   166                                  		
   167 000000CB 8A01                    		mov al, [rcx]
   168 000000CD 8A22                    		mov ah, [rdx]
   169 000000CF 8821                    		mov [rcx], ah
   170 000000D1 8802                    		mov [rdx], al
   171                                  
   172 000000D3 48FFC1                  		inc rcx
   173 000000D6 48FFCA                  		dec rdx
   174                                  		
   175 000000D9 EBEB                    		jmp .loop
   176                                  
   177                                  .loop_end:
   178                                  
   179 000000DB C3                      		ret
   180                                  
   181                                  ;---------------------------------------------------------------------------------
   182                                  ; Converts integer to ASCII string in the specified base.
   183                                  ;
   184                                  ; Entry: RCX - number to be converted,
   185                                  ;        RDX - base,
   186                                  ;        R8 - output string (must be sufficient to hold the number converted).
   187                                  ; Note:  none.
   188                                  ; Exit:  none.
   189                                  ; Chngs: RCX R8 R9 R10
   190                                  ;---------------------------------------------------------------------------------
   191                                  section .text
   192                                  myitoa:
   193 000000DC 4885C9                  		test rcx, rcx
   194 000000DF 7806                    		js .number_is_negative
   195                                  		
   196 000000E1 E85CFFFFFF              		call myitoa_unsigned
   197 000000E6 C3                      		ret
   198                                  
   199                                  .number_is_negative:
   200 000000E7 41C6002D                		mov [r8], byte '-'
   201 000000EB 49FFC0                  		inc r8
   202 000000EE 48F7D1                  		not rcx
   203 000000F1 48FFC1                  		inc rcx                  ; From 2's complement to unsigned value.
   204 000000F4 E849FFFFFF              		call myitoa_unsigned
   205 000000F9 C3                      		ret
   206                                  
   207                                  section .text
   208                                  ; Entry: RCX - character
   209                                  ;
   210                                  tolower:
   211 000000FA 4883F941                		cmp rcx, 'A'
   212 000000FE 720E                    		jb .not_converted
   213                                  		
   214 00000100 4883F95A                		cmp rcx, 'Z'
   215 00000104 7708                    		ja .not_converted
   216                                  		
   217 00000106 4883C120                		add rcx, -'A'+'a'
   218                                  		
   219 0000010A 4889C8                  		mov rax, rcx
   220                                  		
   221 0000010D C3                      		ret
   222                                  
   223                                  .not_converted:
   224 0000010E 4889C8                  		mov rax, rcx
   225 00000111 C3                      		ret
   226                                  
   227                                  section .text
   228                                  ; Entry: RCX - start of the string
   229                                  ;        RDX - address of the zero byte in the string
   230                                  ;
   231                                  tolower_str:
   232 00000112 4989C8                  		mov r8, rcx
   233                                  .loop:
   234 00000115 4939D0                  		cmp r8, rdx
   235 00000118 7311                    		jae .loop_end
   236                                  		
   237 0000011A 490FB608                		movzx rcx, byte [r8]
   238 0000011E E8D7FFFFFF              		call tolower
   239 00000123 418800                  		mov [r8], al
   240                                  		
   241 00000126 49FFC0                  		inc r8
   242                                  		
   243 00000129 EBEA                    		jmp .loop
   244                                  
   245                                  .loop_end:
   246                                  
   247 0000012B C3                      		ret
   248                                  
   249                                  section .text
   250                                  ;--------------------------------------------------------------------
   251                                  ; Returns length of a null terminated string.
   252                                  ;
   253                                  ; Entry: RCX - address of the start of the string
   254                                  ; Note:  max string length is 2^64 - 1.
   255                                  ; Exit:  RAX - length of the string
   256                                  ; Chngs: RAX RCX
   257                                  ;--------------------------------------------------------------------
   258                                  ; size_t strlen( const char * string );
   259                                  mystrlen:
   260 0000012C 57                      		push rdi
   261 0000012D 4889CF                  		mov rdi, rcx
   262                                  
   263 00000130 FC                      		cld
   264 00000131 30C0                    		xor al, al
   265 00000133 48C7C1FFFFFFFF          		mov rcx, -1
   266 0000013A F2AE                    		repne scasb         ; After the instruction rcx is 0xFFFFFFFFFFFFFFFF - (number of non zero symbols + 1).
   267                                  		                    ; rcx is decremeted first, then comparison for rcx = 0 or zf happens.
   268                                  		                    ; after the zero byte cx is decremented as well.
   269                                  		                    ; scasb after comparing zero byte will increment rdi as well.
   270                                  		                    ; RDI = next byte after the terminating zero byte.
   271 0000013C 4883F1FF                		xor rcx, -1         ; RCX = ~rcx = 0xFFFF... - rcx = number of non zero symbols + 1
   272 00000140 48FFC9                  		dec rcx             ; RCX = number of non zero symbols
   273                                  		
   274 00000143 5F                      		pop rdi
   275                                  		
   276 00000144 4889C8                  		mov rax, rcx
   277 00000147 C3                      		ret
   278                                  
   279                                  section .text
   280                                  ;--------------------------------------------------------------------
   281                                  ; Writes null-terminated string to the console.
   282                                  ;
   283                                  ; Entry: RCX - address of the start of the string
   284                                  ; Note:  none
   285                                  ; Exit:  none
   286                                  ; Chngs: RCX RDX
   287                                  ;--------------------------------------------------------------------
   288                                  ; ... puts( ... );
   289                                  myputs:
   290 00000148 50                      		push rax
   291 00000149 51                      		push rcx
   292 0000014A 52                      		push rdx
   293 0000014B 4150                    		push r8
   294 0000014D 4151                    		push r9
   295 0000014F 4152                    		push r10
   296 00000151 4153                    		push r11
   297                                  
   298 00000153 51                      		push rcx
   299 00000154 E8D3FFFFFF              		call mystrlen
   300 00000159 59                      		pop rcx
   301                                  		
   302 0000015A 4889CA                  		mov rdx, rcx
   303 0000015D 488B0D(01000000)        		mov rcx, [rel stdout_handle]
   304 00000164 4989C0                  		mov r8, rax
   305 00000167 4D31C9                  		xor r9, r9
   306 0000016A 6A00                    		push 0
   307 0000016C 4883EC20                		sub rsp, 32
   308 00000170 E8(00000000)            		call WriteFile
   309 00000175 4883C420                		add rsp, 32
   310 00000179 4883C408                		add rsp, 8
   311                                  
   312 0000017D 415B                    		pop r11
   313 0000017F 415A                    		pop r10
   314 00000181 4159                    		pop r9
   315 00000183 4158                    		pop r8
   316 00000185 5A                      		pop rdx
   317 00000186 59                      		pop rcx
   318 00000187 58                      		pop rax
   319                                  		
   320 00000188 C3                      		ret
   321                                  
   322                                  section .text
   323                                  extract_signed_int_arg:
   324                                  		; neg rax
   325                                  		; [base + scale*index + displacement],
   326                                  		; base is any gen. purp register,
   327                                  		; scale is 2, 4, 8, index is any gen. purp registers except esp, rsp,
   328                                  		; displacement is 8-, 16- or 32-bit value.
   329                                  		; Any of the summands may be ommited.
   330 00000189 4983FA00                		cmp r10, SIZE_DEFAULT
   331 0000018D 740C                    		je .extract_int
   332                                  		
   333 0000018F 4983FA02                		cmp r10, SIZE_LONG
   334 00000193 7406                    		je .extract_long
   335                                  		
   336 00000195 4983FA04                		cmp r10, SIZE_LONGLONG
   337 00000199 7406                    		je .extract_longlong
   338                                  .extract_int:
   339                                  .extract_long:
   340 0000019B 486344C418              		movsx rax, dword [rsp+8*rax+24]
   341 000001A0 C3                      		ret
   342                                  
   343                                  .extract_longlong:
   344 000001A1 488B44C418              		mov rax, [rsp+8*rax+24]
   345 000001A6 C3                      		ret
   346                                  
   347                                  section .text
   348                                  extract_unsigned_int_arg:
   349                                  		; neg rax
   350                                  		; [base + scale*index + displacement],
   351                                  		; base is any gen. purp register,
   352                                  		; scale is 2, 4, 8, index is any gen. purp registers except esp, rsp,
   353                                  		; displacement is 8-, 16- or 32-bit value.
   354                                  		; Any of the summands may be ommited.
   355 000001A7 4983FA00                		cmp r10, SIZE_DEFAULT
   356 000001AB 740C                    		je .extract_int
   357                                  		
   358 000001AD 4983FA02                		cmp r10, SIZE_LONG
   359 000001B1 7406                    		je .extract_long
   360                                  		
   361 000001B3 4983FA04                		cmp r10, SIZE_LONGLONG
   362 000001B7 7405                    		je .extract_longlong
   363                                  .extract_int:
   364                                  .extract_long:
   365 000001B9 8B44C418                		mov eax, [rsp+8*rax+24]
   366 000001BD C3                      		ret
   367                                  		
   368                                  .extract_longlong:
   369 000001BE 488B44C418              		mov rax, [rsp+8*rax+24]
   370 000001C3 C3                      		ret
   371                                  
   372                                  section .text
   373                                  extract_addr_arg:
   374                                  		; neg rax
   375                                  		; [base + scale*index + displacement],
   376                                  		; base is any gen. purp register,
   377                                  		; scale is 2, 4, 8, index is any gen. purp registers except esp, rsp,
   378                                  		; displacement is 8-, 16- or 32-bit value.
   379                                  		; Any of the summands may be ommited.
   380 000001C4 488B44C418              		mov rax, [rsp+8*rax+24]
   381 000001C9 C3                      		ret
   382                                  		
   383                                  section .text
   384                                  process_size_specs:
   385 000001CA 4883F87A                		cmp rax, 'z'
   386 000001CE 7407                    		je .set_size_size_t
   387                                  		
   388 000001D0 4883F86C                		cmp rax, 'l'		
   389 000001D4 740F                    		je .process_longs
   390                                  		
   391 000001D6 C3                      		ret
   392                                  .set_size_size_t:
   393 000001D7 41BA01000000            		mov r10, SIZE_SIZE_T
   394 000001DD 480FB601                		movzx rax, byte [rcx]
   395 000001E1 48FFC1                  		inc rcx
   396 000001E4 C3                      		ret
   397                                  .process_longs:
   398 000001E5 41BA02000000            		mov r10, SIZE_LONG
   399                                  				
   400 000001EB 480FB601                		movzx rax, byte [rcx]
   401 000001EF 48FFC1                  		inc rcx
   402 000001F2 4883F86C                		cmp rax, 'l'
   403 000001F6 7401                    		je .set_size_longlong
   404                                  		
   405 000001F8 C3                      		ret
   406                                  .set_size_longlong:
   407 000001F9 41BA04000000            		mov r10, SIZE_LONGLONG
   408 000001FF 480FB601                		movzx rax, byte [rcx]
   409 00000203 48FFC1                  		inc rcx
   410 00000206 C3                      		ret
   411                                  
   412                                  section .text
   413                                  myprintf:
   414 00000207 4889542410              		mov [rsp+16], rdx
   415 0000020C 4C89442418              		mov [rsp+24], r8
   416 00000211 4C894C2420              		mov [rsp+32], r9
   417                                  		; RCX - pointer to the format string
   418                                  		; Arguments are on the stack in shadow space from calling convention. It is faster
   419                                  		; than jump table for argument index and acquision from register and frees some
   420                                  		; registers.
   421                                  		; RAX, RCX, RDX, R8, R9, R10, R11 are caller saved.
   422                                  		; RDX - number of characters written so far
   423                                  		; R8 - current specifier index
   424                                  		; R10 - size of the specifier
   425                                  		; RAX, R9 - tmp registers. RAX is often the current character.
   426                                  		; Encoding is ASCII. If other encoding is in use, the bytes with ASCII numbers
   427                                  		; for '%', 'c', 'd', ..., '\n', '\r' will be treated as ASCII instead of encoding
   428                                  		; in use. Other chars (should? be) printed as bytes.
   429 00000216 4D31C0                  		xor r8, r8
   430 00000219 4831D2                  		xor rdx, rdx
   431 0000021C E811020000              		call get_stdout_handle
   432 00000221 4885C0                  		test rax, rax
   433 00000224 0F8407020000            		jz .failure
   434                                  .loop:
   435 0000022A 480FB601                		movzx rax, byte [rcx]
   436 0000022E 4885C0                  		test rax, rax
   437 00000231 0F84FA010000            		jz .loop_end
   438                                  		
   439 00000237 48FFC1                  		inc rcx
   440                                  		
   441 0000023A 4883F825                		cmp rax, '%'
   442 0000023E 740A                    		je .process_spec
   443                                  
   444 00000240 E8BBFDFFFF              		call write_char
   445 00000245 E9E2010000              		jmp .loop_next_iteration
   446                                  
   447                                  .process_spec:
   448                                  		; Get next char.
   449 0000024A 480FB601                		movzx rax, byte [rcx]
   450 0000024E 48FFC1                  		inc rcx
   451                                  
   452 00000251 41BA00000000            		mov r10, SIZE_DEFAULT
   453 00000257 E86EFFFFFF              		call process_size_specs
   454                                  		
   455                                  		; if rax was less than '%', then treating is as an unsigned, it will be greater than 'o' - '%'
   456                                  		; (-'%' would not overflow signed 64-bit, 'o' would not overflow signed 64-bit, then the
   457                                  		; inequality holds, as any negative value is greater than any positive value if signed integer
   458                                  		; converted to an unsigned). 
   459 0000025C 4883E825                		sub rax, FIRST_SPEC
   460 00000260 4883F853                		cmp rax, LAST_SPEC - FIRST_SPEC
   461 00000264 0F87C2010000            		ja .process_inv_spec
   462 0000026A 4C8D1D(24000000)        		lea r11, [rel .printf_jump_table]
   463 00000271 498B04C3                		mov rax, [r11 + 8 * rax]
   464 00000275 FFE0                    		jmp rax
   465                                  
   466                                  .process_percent:
   467 00000277 B825000000              		mov rax, '%'
   468 0000027C E87FFDFFFF              		call write_char
   469 00000281 4885C0                  		test rax, rax
   470                                  		; ...2
   471 00000284 E9A3010000              		jmp .loop_next_iteration
   472                                  		
   473                                  .process_binary:
   474 00000289 4C89C0                  		mov rax, r8
   475 0000028C 49FFC0                  		inc r8
   476 0000028F E8F5FEFFFF              		call extract_signed_int_arg
   477                                  		
   478 00000294 51                      		push rcx
   479 00000295 52                      		push rdx
   480 00000296 4150                    		push r8
   481 00000298 4151                    		push r9
   482 0000029A 4152                    		push r10
   483                                  		;		RCX - number to be converted,
   484                                  		;        RDX - base,
   485                                  		; R8 - output string (must be sufficient to hold the number converted).
   486 0000029C 4889C1                  		mov rcx, rax
   487 0000029F BA02000000              		mov rdx, 2
   488 000002A4 49B8-                   		mov r8, .number
   488 000002A6 [0000000000000000] 
   489 000002AE E829FEFFFF              		call myitoa
   490 000002B3 415A                    		pop r10
   491 000002B5 4159                    		pop r9
   492 000002B7 4158                    		pop r8
   493 000002B9 5A                      		pop rdx
   494 000002BA 59                      		pop rcx
   495                                  		
   496 000002BB 51                      		push rcx
   497 000002BC 48B9-                   		mov rcx, .number
   497 000002BE [0000000000000000] 
   498 000002C6 E87DFEFFFF              		call myputs
   499 000002CB 59                      		pop rcx
   500                                  		
   501 000002CC E95B010000              		jmp .loop_next_iteration
   502                                  
   503                                  .process_char:
   504 000002D1 4C89C0                  		mov rax, r8
   505 000002D4 49FFC0                  		inc r8
   506 000002D7 E8ADFEFFFF              		call extract_signed_int_arg
   507                                  		
   508 000002DC E81FFDFFFF              		call write_char
   509                                  		
   510 000002E1 E946010000              		jmp .loop_next_iteration
   511                                  
   512                                  .process_int:
   513 000002E6 4C89C0                  		mov rax, r8
   514 000002E9 49FFC0                  		inc r8
   515 000002EC E898FEFFFF              		call extract_signed_int_arg
   516                                  
   517 000002F1 51                      		push rcx
   518 000002F2 52                      		push rdx
   519 000002F3 4150                    		push r8
   520 000002F5 4151                    		push r9
   521 000002F7 4152                    		push r10
   522                                  		;		RCX - number to be converted,
   523                                  		;        RDX - base,
   524                                  		; R8 - output string (must be sufficient to hold the number converted).
   525 000002F9 4889C1                  		mov rcx, rax
   526 000002FC BA0A000000              		mov rdx, 10
   527 00000301 49B8-                   		mov r8, .number
   527 00000303 [0000000000000000] 
   528 0000030B E8CCFDFFFF              		call myitoa
   529 00000310 415A                    		pop r10
   530 00000312 4159                    		pop r9
   531 00000314 4158                    		pop r8
   532 00000316 5A                      		pop rdx
   533 00000317 59                      		pop rcx
   534                                  		
   535 00000318 51                      		push rcx
   536 00000319 48B9-                   		mov rcx, .number
   536 0000031B [0000000000000000] 
   537 00000323 E820FEFFFF              		call myputs
   538 00000328 59                      		pop rcx
   539                                  
   540 00000329 E9FE000000              		jmp .loop_next_iteration
   541                                  
   542                                  .process_octal:
   543 0000032E 4C89C0                  		mov rax, r8
   544 00000331 49FFC0                  		inc r8
   545 00000334 E86EFEFFFF              		call extract_unsigned_int_arg
   546                                  		
   547 00000339 51                      		push rcx
   548 0000033A 52                      		push rdx
   549 0000033B 4150                    		push r8
   550 0000033D 4151                    		push r9
   551 0000033F 4152                    		push r10
   552                                  		;		RCX - number to be converted,
   553                                  		;        RDX - base,
   554                                  		; R8 - output string (must be sufficient to hold the number converted).
   555 00000341 4889C1                  		mov rcx, rax
   556 00000344 BA08000000              		mov rdx, 8
   557 00000349 49B8-                   		mov r8, .number
   557 0000034B [0000000000000000] 
   558 00000353 E8EAFCFFFF              		call myitoa_unsigned
   559 00000358 415A                    		pop r10
   560 0000035A 4159                    		pop r9
   561 0000035C 4158                    		pop r8
   562 0000035E 5A                      		pop rdx
   563 0000035F 59                      		pop rcx
   564                                  		
   565 00000360 51                      		push rcx
   566 00000361 48B9-                   		mov rcx, .number
   566 00000363 [0000000000000000] 
   567 0000036B E8D8FDFFFF              		call myputs
   568 00000370 59                      		pop rcx
   569                                  
   570 00000371 E9B6000000              		jmp .loop_next_iteration
   571                                  
   572                                  .process_string:
   573 00000376 4C89C0                  		mov rax, r8
   574 00000379 49FFC0                  		inc r8
   575 0000037C E843FEFFFF              		call extract_addr_arg
   576                                  		
   577 00000381 51                      		push rcx
   578 00000382 4889C1                  		mov rcx, rax
   579 00000385 E8BEFDFFFF              		call myputs
   580 0000038A 59                      		pop rcx
   581                                  		
   582 0000038B E99C000000              		jmp .loop_next_iteration
   583                                  
   584                                  .process_lowercase_hex:
   585 00000390 4C89C0                  		mov rax, r8
   586 00000393 49FFC0                  		inc r8
   587 00000396 E80CFEFFFF              		call extract_unsigned_int_arg
   588                                  		
   589 0000039B 51                      		push rcx
   590 0000039C 52                      		push rdx
   591 0000039D 4150                    		push r8
   592 0000039F 4151                    		push r9
   593 000003A1 4152                    		push r10
   594                                  		;		RCX - number to be converted,
   595                                  		;        RDX - base,
   596                                  		; R8 - output string (must be sufficient to hold the number converted).
   597 000003A3 4889C1                  		mov rcx, rax
   598 000003A6 BA10000000              		mov rdx, 16
   599 000003AB 49B8-                   		mov r8, .number
   599 000003AD [0000000000000000] 
   600 000003B5 E888FCFFFF              		call myitoa_unsigned
   601                                  		
   602 000003BA 4C89C2                  		mov rdx, r8
   603 000003BD 48B9-                   		mov rcx, .number
   603 000003BF [0000000000000000] 
   604 000003C7 E846FDFFFF              		call tolower_str
   605                                  		
   606 000003CC 415A                    		pop r10
   607 000003CE 4159                    		pop r9
   608 000003D0 4158                    		pop r8
   609 000003D2 5A                      		pop rdx
   610 000003D3 59                      		pop rcx
   611                                  		
   612 000003D4 51                      		push rcx
   613 000003D5 48B9-                   		mov rcx, .number
   613 000003D7 [0000000000000000] 
   614 000003DF E864FDFFFF              		call myputs
   615 000003E4 59                      		pop rcx
   616                                  
   617 000003E5 EB45                    		jmp .loop_next_iteration
   618                                  		
   619                                  .process_uppercase_hex:
   620 000003E7 4C89C0                  		mov rax, r8
   621 000003EA 49FFC0                  		inc r8
   622 000003ED E8B5FDFFFF              		call extract_unsigned_int_arg
   623                                  		
   624 000003F2 51                      		push rcx
   625 000003F3 52                      		push rdx
   626 000003F4 4150                    		push r8
   627 000003F6 4151                    		push r9
   628 000003F8 4152                    		push r10
   629                                  		;		RCX - number to be converted,
   630                                  		;        RDX - base,
   631                                  		; R8 - output string (must be sufficient to hold the number converted).
   632 000003FA 4889C1                  		mov rcx, rax
   633 000003FD BA10000000              		mov rdx, 16
   634 00000402 49B8-                   		mov r8, .number
   634 00000404 [0000000000000000] 
   635 0000040C E831FCFFFF              		call myitoa_unsigned
   636 00000411 415A                    		pop r10
   637 00000413 4159                    		pop r9
   638 00000415 4158                    		pop r8
   639 00000417 5A                      		pop rdx
   640 00000418 59                      		pop rcx
   641                                  		
   642 00000419 51                      		push rcx
   643 0000041A 48B9-                   		mov rcx, .number
   643 0000041C [0000000000000000] 
   644 00000424 E81FFDFFFF              		call myputs
   645 00000429 59                      		pop rcx
   646                                  
   647 0000042A EB00                    		jmp .loop_next_iteration
   648                                  
   649                                  .process_inv_spec:
   650                                  
   651                                  .loop_next_iteration:		
   652 0000042C E9F9FDFFFF              		jmp .loop
   653                                  		
   654                                  		
   655                                  .loop_end:
   656                                  
   657                                  .failure:
   658 00000431 C3                      		ret
   659                                  
   660                                  section .rdata
   661                                  
   662                                  SIZE_DEFAULT  equ 0
   663                                  SIZE_SIZE_T   equ 1
   664                                  SIZE_LONG     equ 2
   665                                  SIZE_LONGLONG equ 4
   666                                  
   667                                  FIRST_SPEC equ '%'
   668                                  LAST_SPEC equ 'x'
   669                                  ; '%', 'b', 'c', 'd', 'o', 's'
   670                                  .printf_jump_table:
   671 00000024 [7702000000000000]      	dq .process_percent                                    ; '%'
   672 0000002C [2C04000000000000]-     	times ('X' - '%' - 1) dq .process_inv_spec             ; ('%', 'X') = ('X', 0] / ('%', 0] / {'%'}
   672 0000002C <rept>             
   673 000001BC [E703000000000000]      	dq .process_uppercase_hex                              ; 'X'
   674 000001C4 [2C04000000000000]-     	times ('b' - 'X' - 1) dq .process_inv_spec ; ('X', 'b') = ('b', 0] / ('X', 0] / {'X'}
   674 000001C4 <rept>             
   675 0000020C [8902000000000000]      	dq .process_binary                                     ; 'b'
   676 00000214 [D102000000000000]      	dq .process_char                                       ; 'c'
   677 0000021C [E602000000000000]      	dq .process_int                                        ; 'd'
   678 00000224 [2C04000000000000]-     	times ('o' - 'd' - 1) dq .process_inv_spec             ; ('d', 'o') = ('o', 0] / ('d', 0] / {'d'}
   678 00000224 <rept>             
   679 00000274 [2E03000000000000]      	dq .process_octal                                      ; 'o'
   680 0000027C [2C04000000000000]-     	times ('s' - 'o' - 1) dq .process_inv_spec             ; ('o', 's') = ('s', 0] / ('o', 0) / {'o'}
   680 0000027C <rept>             
   681 00000294 [7603000000000000]      	dq .process_string                                     ; 's'
   682 0000029C [2C04000000000000]-     	times ('x' - 's' - 1) dq .process_inv_spec             ; ('s', 'x') = ('x', 0] / ('s', 0) / {'s'}
   682 0000029C <rept>             
   683 000002BC [9003000000000000]      	dq .process_lowercase_hex                              ; 'x'
   684                                  
   685                                  section .data
   686 00000000 00<rept>                .number: times (1 + 64 + 1) db 0
   687                                  
   688                                  
   689                                  section .text
   690                                  get_stdout_handle:
   691 00000432 51                      		push rcx
   692 00000433 52                      		push rdx
   693 00000434 4150                    		push r8
   694 00000436 4151                    		push r9
   695                                  		
   696 00000438 48C7C1F5FFFFFF          		mov rcx, STD_OUTPUT_HANDLE
   697 0000043F 4883EC20                		sub rsp, 32
   698 00000443 E8(00000000)            		call GetStdHandle
   699 00000448 4883C420                		add rsp, 32
   700 0000044C 4883F8FF                		cmp rax, INVALID_HANDLE_VALUE
   701 00000450 7413                    		je .invalid_handle
   702                                  		
   703 00000452 488905(01000000)        		mov [rel stdout_handle], rax
   704 00000459 B801000000              		mov rax, 1
   705                                  
   706 0000045E 4159                    		pop r9
   707 00000460 4158                    		pop r8
   708 00000462 5A                      		pop rdx
   709 00000463 59                      		pop rcx
   710 00000464 C3                      		ret
   711                                  .invalid_handle:
   712 00000465 B800000000              		mov rax, 0
   713                                  
   714 0000046A 4159                    		pop r9
   715 0000046C 4158                    		pop r8
   716 0000046E 5A                      		pop rdx
   717 0000046F 59                      		pop rcx
   718 00000470 C3                      		ret
   719                                  
   720                                  section .data
   721 00000042 0000000000000000        ferror_flag dq 0
   722                                  		
   723                                  section .bss
   724 00000001 <res 00000008>          stdout_handle resq 1
