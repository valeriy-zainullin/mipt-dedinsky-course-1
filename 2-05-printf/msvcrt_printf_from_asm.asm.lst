     1                                  %include "winapi.inc"
     1                              <1> STD_OUTPUT_HANDLE equ -11
     2                              <1> INVALID_HANDLE_VALUE equ -1
     2                                  
     3                                  ; kernel32.dll
     4                                  ; 2022.03.21: libkernel32.a used by x86_64-w64-mingw32-gcc has functions (not one, BaseCheckRunApp, for example)
     5                                  ;             not exported by kernel32.dll anymore. Looks like it wasn't updated yet. The program won't start
     6                                  ;             because of this.
     7                                  ; I directly link with a dll in this case. It is still dynamically linked (easy to check with pe-bear). I think
     8                                  ; it just checks the functions are there, multiple definitions from dlls maybe, undefined references and writes
     9                                  ; the name of the dll.
    10                                  
    11                                  ; msvcrt.dll
    12                                  extern printf
    13                                  
    14                                  ; kernel32.dll
    15                                  extern ExitProcess
    16                                  
    17                                  global __start
    18                                  
    19                                  section .text
    20                                  
    21                                  __start:
    22 00000000 48B9-                   		mov rcx, format_string
    22 00000002 [0000000000000000] 
    23 0000000A BA0BAD5FFE              		mov edx, -27284213
    24 0000000F 41B8EB32A4F8            		mov r8d, -123456789
    25 00000015 41B9F9515C07            		mov r9d, 123490809
    26                                  		; The byte code will contain 64-bit value. The operand is treated as signed and nasm here will
    27                                  		; sign-expand it to the 64 bits. It's not distinguishable from pushing qword on the stack (what was
    28                                  		; pushed qword or dword), but it is not distinguishable for printf anyway, it will figure out the
    29                                  		; value by looking at the format string.
    30                                  		; DWORD here is about preparing the value to fill 64 bits before pushing. The same for byte, as I
    31                                  		; found in the internet (there was the same issue with 32-bits and a byte, so I think I deal with
    32                                  		; the same here).
    33                                  		; https://groups.google.com/g/comp.lang.asm.x86/c/3A88dt_uPYk
    34                                  		;push dword 0xDED9DED9
    35                                  		;push dword 0xded9ded9
    36                                  		; ---
    37                                  		; In 16-bit mode, you can push 16 or (with operand-size prefix on 386 and later) 32 bits.
    38                                  		; In 32-bit mode, you can push 32 or (with operand-size prefix) 16 bits.
    39                                  		; In 64-bit mode, you can push 64 or (with operand-size prefix) 16 bits.
    40                                  		; https://stackoverflow.com/a/45134007
    41                                  		; And after that I had found out that there one can't push even 64 bits immediate in 64-bit mode.
    42                                  		; Only 32-bit. Maybe it was done to reduce redundancy. Just use mov and sub after, and everything
    43                                  		; is done. Yes, as it is needed to store arguments, but then there are many of them likely, so
    44                                  		; plus one intruction is not a problem, but less redundancy. And registers are still possible to
    45                                  		; be saved.
    46                                  		; Stack is always aligned on 8-byte boundary, we effectively aren't pushing a dword here.
    47                                  		; ---
    48                                  		; Can't do this either. The only x86-64 instruction that can use a 64-bit immediate is mov-immediate
    49                                  		; to register, the special no-modrm opcode that gives us 5-byte mov eax, 12345, or 10-byte
    50                                  		; mov rax, 0x0123456789abcdef, where a REX.W prefix changes that opcode to look for a 64-bit immediate.
    51                                  		; See https://www.felixcloutier.com/x86/mov / why we can't move a 64-bit immediate value to memory?
    52                                  		;mov qword [rsp-16], 0xDED9DED9
    53                                  		;mov qword [rsp-8], 0xded9ded9
    54                                  		; https://stackoverflow.com/a/70731545
    55                                  		; ---
    56                                  		; I have to use a temporary register. Maybe because storing contants is not a very often operations
    57                                  		; and it doesn't break pipelining, so not a big deal for another command involved. And it can be
    58                                  		; stored in register if it is used for a long time, there are more registers now, maybe...
    59 0000001B 41BED9DED9DE            		mov r14d, 0xDED9DED9
    60 00000021 4156                    		push r14
    61 00000023 41BED9DED9DE            		mov r14d, 0xded9ded9
    62 00000029 4156                    		push r14
    63 0000002B 6848E9E93F              		push dword 0o7772364510
    64                                  
    65 00000030 4883EC20                		sub rsp, 32
    66 00000034 E8(00000000)            		call printf
    67 00000039 4883C420                		add rsp, 32
    68                                  
    69 0000003D 4831C9                  		xor rcx, rcx
    70 00000040 4883EC20                		sub rsp, 32
    71 00000044 E8(00000000)            		call ExitProcess       ; ExitProcess (0)
    72 00000049 4883C420                		add rsp, 32
    73                                  
    74                                  section .data
    75                                  
    76                                  LF equ 0xA ; '\n'
    77 00000000 256420256920257520-     format_string: db "%d %i %u %o %x %X ", LF, 0, "%f %F %e %E %g %G %a %A %c %s %p %n %%\n", 0
    77 00000009 256F20257820255820-
    77 00000012 0A0025662025462025-
    77 0000001B 652025452025672025-
    77 00000024 472025612025412025-
    77 0000002D 632025732025702025-
    77 00000036 6E2025255C6E00     
