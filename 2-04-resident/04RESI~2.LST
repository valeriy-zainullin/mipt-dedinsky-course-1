Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 1
04resi~2.asm



      1				     ﻿.186
      2	0000			     .model tiny
      3	0000			     .code
      4				     locals
      5				     org 100h
      6
      7	0100			     start:
      8	0100  BB 0008				     mov bx, 8
      9	0103  BF 03D1r				     mov di, offset int8_jmp_far_arg
     10	0106  BE 03B2r				     mov si, offset int8_handler
     11	0109  E8 0120				     call set_int
     12
     13	010C  BB 0009				     mov bx, 9
     14	010F  BF 0483r				     mov di, offset int9_jmp_far_arg
     15	0112  BE 03D5r				     mov si, offset int9_handler
     16	0115  E8 0114				     call set_int
     17
     18	0118  E8 0104				     call go_resident
     19
     20				     include ..\2-03-S~1\03.asm
1    21				     ﻿locals
1    22
1    23				     ;--------------------------------------------------------------------
1    24				     ; Returns length of a null	terminated string.
1    25				     ;
1    26				     ; Entry: ES:DI - address of the start of the string
1    27				     ; Note:  max string length	is 65535.
1    28				     ; Exit:  AL = 0
1    29				     ;	      CX - length of the string
1    30				     ;	      DI - next	byte after the zero byte of the	string
1    31				     ; Chngs: AL CX DI
1    32				     ;--------------------------------------------------------------------
1    33				     ; size_t strlen( const char * string );
1    34	011B			     strlen proc
1    35	011B  FC				     cld
1    36
1    37	011C  32 C0				     xor al, al
1    38	011E  B9 FFFF				     mov cx, 0ffffh
1    39	0121  F2> AE				     repne scasb	 ; After the instruction cx is 0xFFFF -	(number	of non zero +
     40				     symbols + 1).
1    41									 ; cx is decremeted first, then	comparison for cx = 0 or zf +
     42				     happens.
1    43									 ; after the zero byte cx is decremented as well.
1    44									 ; scasb after comparing zero byte will	increment di as	well.
1    45									 ; DI =	next byte after	the terminating	zero byte.
1    46	0123  83 F1 FF				     xor cx, 0ffffh	 ; CX =	~CX = 0xFFFF - cx = number of non zero symbols + 1
1    47	0126  49				     dec cx		 ; CX =	number of non zero symbols
1    48
1    49	0127  C3				     ret
1    50	0128			     endp
1    51
1    52				     ;--------------------------------------------------------------------
1    53				     ; Looks for character in a	null-terminated	string.
1    54				     ;
1    55				     ; Entry: ES:DI - address of the start of the string,
1    56				     ;	      AL    - character	to be found
1    57				     ; Note:  max string length	is 65535.
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 2
04resi~2.asm



1    58				     ; Exit:  AH = 0,
1    59				     ;	      DI - address of the character found or zero
1    60				     ;	      CX - length - index of character - 1 (0-based) or	0 if not found
1    61				     ; Chngs: AX CX DI
1    62				     ;--------------------------------------------------------------------
1    63				     ; char * strchr( const char * string, int symbol);
1    64	0128			     strchr proc
1    65	0128  FC				     cld
1    66
1    67	0129  86 E0				     xchg ah, al
1    68	012B  E8 FFED				     call strlen
1    69	012E  86 E0				     xchg ah, al
1    70
1    71	0130  85 C9				     test cx, cx
1    72	0132  74 0B				     jz	@@not_found   ;	taken if length	is zero	to not feed it to rep**. It will    +
     73				     iterate over 0xFFFF + 1 items otherwise.
1    74
1    75						     ; DI = address of the byte	after the terminating zero.
1    76	0134  4F				     dec di
1    77	0135  2B F9				     sub di, cx
1    78						     ; CX = start of the string
1    79
1    80	0137  F2> AE				     repne scasb      ;	After comparing	the zero byte, di is still incremented.
1    81	0139  4F				     dec di	      ;	Decrement it back.
1    82
1    83	013A  85 C9				     test cx, cx
1    84	013C  74 01				     jz	@@not_found
1    85
1    86	013E  C3				     ret
1    87
1    88	013F			     @@not_found:
1    89	013F  33 FF				     xor di, di
1    90	0141  C3				     ret
1    91	0142			     endp
1    92
1    93				     ;--------------------------------------------------------------------
1    94				     ; Copies string to	a buffer. At most num bytes written to the buffer.
1    95				     ;
1    96				     ; Entry: ES:DI - destination address
1    97				     ;	      DS:SI - source address
1    98				     ;	      BX    - max number of bytes written for dest. address
1    99				     ; Note:  max string length	is 65535.
1   100				     ; Exit:   = 0,
1   101				     ;	      DI - address of the character found or zero
1   102				     ;	      CX - length - index of character - 1 (0-based)
1   103				     ; Chngs: AX BX CX SI DI
1   104				     ;--------------------------------------------------------------------
1   105				     ; char * strncpy( char * destptr, const char * srcptr, size_t num );
1   106				     ; Rethink.	May be broken as hell.
1   107	0142			     strncpy proc
1   108	0142  FC				     cld
1   109
1   110	0143  8C D8				     mov ax, ds
1   111	0145  8C C1				     mov cx, es
1   112	0147  8E D9				     mov ds, cx
1   113	0149  8E C0				     mov es, ax
1   114	014B  87 FE				     xchg di, si
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 3
04resi~2.asm



1   115
1   116						     ;--------------------------------------------------------------------
1   117						     ; Returns length of a null	terminated string.
1   118						     ;
1   119						     ; Entry: ES:DI - address of the start of the string
1   120						     ; Note:  max string length	is 65535.
1   121						     ; Exit:  AL = 0
1   122						     ;	      CX - length of the string
1   123						     ;	      DI - next	byte after the zero byte of the	string
1   124						     ; Chngs: AL CX DI
1   125						     ;--------------------------------------------------------------------
1   126						     ; size_t strlen( const char * string );
1   127	014D  E8 FFCB				     call strlen
1   128	0150  41				     inc cx						 ; CX =	length + 1
1   129						     ; SI is at	the byte after the zero	byte.
1   130						     ; sub di, cx
1   131
1   132	0151  3B CB				     cmp cx, bx
1   133	0153  72 05				     jb	@@fill_with_zeros
1   134	0155  77 14				     ja	@@limit_output
1   135	0157  EB 17 90				     jmp @@do_copy
1   136
1   137	015A			     @@fill_with_zeros:
1   138	015A  2B D9				     sub bx, cx
1   139
1   140	015C  03 FB				     add di, bx
1   141	015E  87 D9				     xchg bx, cx
1   142	0160  FD				     std
1   143	0161  32 C0				     xor al, al
1   144	0163  F3> AA				     rep stosb
1   145	0165  FC				     cld
1   146
1   147	0166  87 D9				     xchg bx, cx
1   148
1   149						     ; DI is now shifted for -(1 + (BX - CX)) at the start of the string as before.
1   150
1   151	0168  EB 06 90				     jmp @@do_copy
1   152
1   153	016B			     @@limit_output:
1   154	016B  8B CB				     mov cx, bx
1   155	016D  EB 01 90				     jmp @@do_copy
1   156
1   157	0170			     @@do_copy:
1   158	0170  8C D8				     mov ax, ds
1   159	0172  8C C3				     mov bx, es
1   160	0174  8E DB				     mov ds, bx
1   161	0176  8E C0				     mov es, ax
1   162	0178  87 FE				     xchg di, si
1   163
1   164	017A  F3> A4				     rep movsb
1   165
1   166	017C  C3				     ret
1   167	017D			     endp
1   168
1   169				     ;--------------------------------------------------------------------
1   170				     ; Compares	two strings. Considers first n bytes.
1   171				     ;
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 4
04resi~2.asm



1   172				     ; Entry: ES:DI - first string
1   173				     ;	      DS:SI - second string
1   174				     ;	      BX    - number of	bytes considered
1   175				     ; Note:  max string length	is 65535.
1   176				     ; Exit:   = 0,
1   177				     ; Chngs: AH CX DI
1   178				     ;--------------------------------------------------------------------
1   179				     ; int strncmp( const char * string1, const	char * string2,	size_t num );
1   180	017D			     strncmp proc
1   181	017D  FC				     cld
1   182
1   183	017E  E8 FF9A				     call strlen
1   184
1   185
1   186
1   187	0181  F3> A6				     repe cmpsb
1   188	0183			     endp
1   189
1   190				     ;---------------------------------------------------------------------------------
1   191				     ; Converts	integer	to ASCII string	in the specified base.
1   192				     ;
1   193				     ; Entry: AX - number to be	converted,
1   194				     ;	      BX - base,
1   195				     ;	      ES:DI - output string (must be sufficient	to hold	the number converted).
1   196				     ; Note:  none.
1   197				     ; Exit:  DS:DI - address of the zero byte of the string
1   198				     ; Chngs: BX DX
1   199				     ;---------------------------------------------------------------------------------
1   200				     ; void* itoa(int input, char *buffer, int radix)
1   201				     ; TODO: handle negative values.
1   202				     ; TODO: optimize a	little bit more.
1   203	0183			     itoa proc
1   204
1   205	0183  56				     push si
1   206
1   207						     ; UB if base if less than 2 or greater than 36
1   208						     ; cmp bx, 2
1   209						     ; jl @@invalid_base
1   210						     ; cmp bx, 36
1   211						     ; jg @@invalid_base
1   212
1   213	0184  57				     push di
1   214
1   215	0185  85 C0				     test ax, ax
1   216	0187  74 4F				     jz	@@number_is_zero
1   217
1   218	0189  8B D3				     mov dx, bx
1   219	018B  4A				     dec dx
1   220	018C  85 D3				     test dx, bx
1   221
1   222	018E  74 16				     jz	@@power_of_2
1   223
1   224				     ; General base
1   225	0190			     @@general_base_loop:
1   226	0190  85 C0				     test ax, ax
1   227	0192  74 38				     jz	@@loop_end
1   228
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 5
04resi~2.asm



1   229	0194  33 D2				     xor dx, dx
1   230	0196  F7 F3				     div bx
1   231
1   232	0198  8B F2				     mov si, dx
1   233	019A  32 F6				     xor dh, dh
1   234	019C  8A 94 01E1r			     mov dl, @@char_table[si * 1]
1   235
1   236	01A0  26: 89 15				     mov es:[di], dx
1   237	01A3  47				     inc di
1   238
1   239	01A4  EB EA				     jmp @@general_base_loop
1   240
1   241	01A6			     @@power_of_2:
1   242	01A6  32 C9				     xor cl, cl
1   243	01A8			     @@power_loop:
1   244	01A8  83 FB 01				     cmp bx, 1
1   245	01AB  74 06				     je	@@power_calculated
1   246
1   247	01AD  FE C1				     inc cl
1   248	01AF  D1 EB				     shr bx, 1
1   249
1   250	01B1  EB F5				     jmp @@power_loop
1   251	01B3			     @@power_calculated:
1   252
1   253	01B3  D3 E3				     shl bx, cl
1   254	01B5  4B				     dec bx
1   255	01B6			     @@power_of_2_loop:
1   256	01B6  85 C0				     test ax, ax
1   257	01B8  74 12				     jz	@@loop_end
1   258
1   259	01BA  8B F0				     mov si, ax
1   260	01BC  23 F3				     and si, bx
1   261	01BE  32 F6				     xor dh, dh
1   262	01C0  8A 94 01E1r			     mov dl, @@char_table[si * 1]
1   263
1   264	01C4  26: 89 15				     mov es:[di], dx
1   265	01C7  47				     inc di
1   266
1   267	01C8  D3 E8				     shr ax, cl
1   268	01CA  EB EA				     jmp @@power_of_2_loop
1   269
1   270	01CC			     @@loop_end:
1   271
1   272	01CC  26: C6 05	00			     mov byte ptr es:[di], 0
1   273
1   274	01D0  5E				     pop si
1   275	01D1  57				     push di
1   276	01D2  E8 0030				     call reverse_string
1   277	01D5  5F				     pop di
1   278
1   279	01D6  5E				     pop si
1   280
1   281	01D7  C3				     ret
1   282
1   283	01D8			     @@number_is_zero:
1   284	01D8  5E				     pop si
1   285
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 6
04resi~2.asm



1   286	01D9  B0 30				     mov al, '0'
1   287	01DB  AA				     stosb
1   288	01DC  32 C0				     xor al, al
1   289	01DE  AA				     stosb
1   290
1   291	01DF  5E				     pop si
1   292	01E0  C3				     ret
1   293
1   294				     ;@@invalid_base:
1   295				     ;		     pop di
1   296				     ;		     ret
1   297
1   298	01E1  30 31 32 33 34 35	36+  @@char_table db '0', '1', '2', '3', '4', '5', '6',	'7', '8', '9'
    299	      37 38 39
1   300	01EB  41 42 43 44 45 46	47+		  db 'A', 'B', 'C', 'D', 'E', 'F', 'G',	'H', 'I', 'J'
    301	      48 49 4A
1   302	01F5  4B 4C 4D 4E 4F 50	51+		  db 'K', 'L', 'M', 'N', 'O', 'P', 'Q',	'R', 'S', 'T'
    303	      52 53 54
1   304	01FF  55 56 57 58 59 5A			  db 'U', 'V', 'W', 'X', 'Y', 'Z'
1   305
1   306	0205			     endp
1   307
1   308				     ;
1   309				     ; Entry: ES:SI - start of the string
1   310				     ;	      ES:DI - address of the zero byte in the string
1   311				     ;
1   312	0205			     reverse_string proc
1   313	0205  4F				     dec di
1   314
1   315	0206  52				     push dx
1   316
1   317	0207			     @@loop:
1   318	0207  3B F7				     cmp si, di
1   319	0209  73 12				     jae @@loop_end
1   320
1   321	020B  26: 8A 14				     mov dl, es:[si]
1   322	020E  26: 8A 35				     mov dh, es:[di]
1   323	0211  86 D6				     xchg dl, dh
1   324	0213  26: 88 14				     mov es:[si], dl
1   325	0216  26: 88 35				     mov es:[di], dh
1   326
1   327	0219  46				     inc si
1   328	021A  4F				     dec di
1   329
1   330	021B  EB EA				     jmp @@loop
1   331	021D			     @@loop_end:
1   332
1   333	021D  5A				     pop dx
1   334
1   335	021E  C3				     ret
1   336	021F			     endp
1   337
1   338				     ;---------------------------------------------------------------------------------
1   339				     ; Converts	ASCII string in	base 10	to string.
1   340				     ;
1   341				     ; Entry: AX - number to be	converted,
1   342				     ;	      BX - base,
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 7
04resi~2.asm



1   343				     ;	      DS:SI - output string (must be sufficient	to hold	the number converted).
1   344				     ; Note:  none.
1   345				     ; Exit:  DS:SI - address of the zero byte of the string
1   346				     ; Chngs: BX DX
1   347				     ;---------------------------------------------------------------------------------
1   348				     ; void* itoa(int input, char *buffer, int radix)
1   349	021F			     atoi proc
1   350	021F			     endp
1   351
    352
    353				     ;--------------------------------------------------------------------
    354				     ; Go resident.
    355				     ;
    356				     ; Entry: none
    357				     ; Note:  none
    358				     ; Exit:  ES = 0
    359				     ; Chngs: AX DX
    360				     ;--------------------------------------------------------------------
    361	021F			     go_resident proc
    362	021F  B8 3100				     mov ax, 3100h
    363	0222  BA 04BFr				     mov dx, offset end_of_program
    364	0225  C1 EA 04				     shr dx, 4				 ; Number of bytes in paragraphs (chunks of +
    365				     16	bytes)
    366	0228  42				     inc dx				 ; Might not be	a multiple of 16
    367
    368	0229  CD 21				     int 21h				 ; TSR:	terminate and stay resident.
    369
    370	022B  C3				     ret				 ; Never executed actually.
    371	022C			     endp
    372
    373				     ;--------------------------------------------------------------------
    374				     ; Changes entry in	interrupt table, saving	old value.
    375				     ;
    376				     ; Entry: BX    - interrupt	number
    377				     ;	      DI    - address in ds segment to store offset and	segment
    378				     ;	      SI    - address in cs segment of the new handler
    379				     ; Note:  none
    380				     ; Exit:  ES = 0
    381				     ; Chngs: AX BX ES
    382				     ;--------------------------------------------------------------------
    383	022C			     set_int proc
    384	022C  FA				     cli
    385
    386	022D  33 C0				     xor ax, ax
    387	022F  8E C0				     mov es, ax
    388
    389	0231  C1 E3 02				     shl bx, 2				 ; multiply bx by 4 so that it is address of+
    390				     the offset.
    391	0234  26: 8B 07				     mov ax, es:[bx]
    392	0237  89 05				     mov [di], ax
    393	0239  26: 8B 47	02			     mov ax, es:[bx+2]
    394	023D  89 45 02				     mov [di+2], ax
    395
    396	0240  26: 89 37				     mov es:[bx], si
    397	0243  26: 8C 4F	02			     mov es:[bx+2], cs
    398
    399	0247  FB				     sti
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 8
04resi~2.asm



    400
    401	0248  C3				     ret
    402	0249			     endp
    403
    404				     ;--------------------------------------------------------------------
    405				     ; Restore previously saved	value of interrupt table entry
    406				     ;
    407				     ; Entry: BX    - interrupt	number
    408				     ;	      DI    - address in ds segment of the stored offset and segment
    409				     ; Note:  none
    410				     ; Exit:  ES = 0
    411				     ; Chngs: AX BX ES
    412				     ;--------------------------------------------------------------------
    413	0249			     restore_int proc
    414	0249  FA				     cli
    415
    416	024A  33 C0				     xor ax, ax
    417	024C  8E C0				     mov es, ax
    418
    419	024E  C1 E3 02				     shl bx, 2				 ; multiply bx by 4 so that it is address of+
    420				     the offset.
    421	0251  8B 05				     mov ax, [di]
    422	0253  26: 89 07				     mov es:[bx], ax
    423	0256  8B 45 02				     mov ax, [di+2]
    424	0259  26: 89 47	02			     mov es:[bx+2], ax
    425
    426	025D  FB				     sti
    427
    428	025E  C3				     ret
    429	025F			     endp
    430
    431
    432				     ;--------------------------------------------------------------------
    433				     ; Saves register values to	display	them later.
    434				     ;
    435				     ; Entry: none
    436				     ; Note:  none
    437				     ; Exit:  none
    438				     ; Chngs: AX
    439				     ;--------------------------------------------------------------------
    440	025F			     save_registers proc
    441	025F  2E: A3 048Br			     mov cs:register_table[0 * 2], ax
    442	0263  2E: 89 1E	048Dr			     mov cs:register_table[1 * 2], bx
    443	0268  2E: 89 0E	048Fr			     mov cs:register_table[2 * 2], cx
    444	026D  2E: 89 16	0491r			     mov cs:register_table[3 * 2], dx
    445	0272  2E: 89 36	0493r			     mov cs:register_table[4 * 2], si
    446	0277  2E: 89 3E	0495r			     mov cs:register_table[5 * 2], di
    447
    448	027C  8C D8				     mov ax, ds
    449	027E  2E: A3 0497r			     mov cs:register_table[6 * 2], ax
    450
    451	0282  8C C0				     mov ax, es
    452	0284  2E: A3 0499r			     mov cs:register_table[7 * 2], ax
    453
    454	0288  C3				     ret
    455	0289			     endp
    456
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 9
04resi~2.asm



    457				     ;---------------------------------------------------------------
    458				     ; Draws one line of a frame
    459				     ;
    460				     ; Entry: BX - first symbol
    461				     ;	      AX - middle symbol (that is repeated)
    462				     ;	      DX - last	symbol
    463				     ;	      DI - starting addr to draw
    464				     ; Note:  ES - videoseg addr
    465				     ; Exit:  DI - starting address of the next	line, CX = 0, DF = 0
    466				     ; Chngs: CX DI DF
    467				     ;---------------------------------------------------------------
    468	0289			     draw_frame_line proc
    469	0289  FC				     cld
    470
    471	028A  B9 000B 90			     mov cx, FRAME_COLS
    472
    473	028E  93				     xchg bx, ax
    474	028F  AB				     stosw
    475	0290  93				     xchg bx, ax
    476	0291  49				     dec cx
    477
    478	0292  49				     dec cx	       ; need to loop line length - 2 times
    479	0293  F3> AB				     rep stosw
    480
    481	0295  92				     xchg dx, ax
    482	0296  AB				     stosw
    483	0297  92				     xchg dx, ax
    484
    485	0298  C3				     ret
    486	0299			     endp
    487
    488
    489				     ;---------------------------------------------------------------
    490				     ; Draws frame.
    491				     ;
    492				     ; Entry: none
    493				     ; Note:  ES - videoseg addr
    494				     ; Exit:  none
    495				     ; Chngs: AX BX DX SI DI
    496				     ;---------------------------------------------------------------
    497	0299			     draw_frame	proc
    498	0299  8B 36 04BDr			     mov si, current_frame_style
    499
    500						     ; Set foreground and background.
    501	029D  B7 07				     mov bh, 7
    502	029F  8A E7				     mov ah, bh
    503	02A1  8A F4				     mov dh, ah
    504
    505	02A3  8A 5C 02 90			     mov bl, [si + BORDER_TL_CORNER_OFFSET]
    506	02A7  8A 44 01 90			     mov al, [si + BORDER_HOR_PLAIN_OFFSET]
    507	02AB  8A 54 03 90			     mov dl, [si + BORDER_TR_CORNER_OFFSET]
    508
    509	02AF  BF 0000				     mov di, 0
    510	02B2  E8 FFD4				     call draw_frame_line
    511
    512	02B5  8A 1C 90 90			     mov bl, [si + BORDER_VERT_PLAIN_OFFSET]
    513	02B9  B0 20				     mov al, ' '
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 10
04resi~2.asm



    514	02BB  8A 14 90 90			     mov dl, [si + BORDER_VERT_PLAIN_OFFSET]
    515
    516	02BF  BE 0008 90			     mov si, FRAME_ROWS	- 2
    517	02C3			     @@loop:
    518	02C3  85 F6				     test si, si
    519	02C5  74 0A				     jz	@@loop_end
    520
    521	02C7  81 C7 008A			     add di, 2 * (SCREEN_COLS -	FRAME_COLS)
    522
    523	02CB  E8 FFBB				     call draw_frame_line
    524
    525	02CE  4E				     dec si
    526
    527	02CF  EB F2				     jmp @@loop
    528	02D1			     @@loop_end:
    529
    530	02D1  81 C7 008A			     add di, 2 * (SCREEN_COLS -	FRAME_COLS)
    531
    532	02D5  8B 36 04BDr			     mov si, current_frame_style
    533	02D9  8A 5C 04 90			     mov bl, [si + BORDER_BL_CORNER_OFFSET]
    534	02DD  8A 44 01 90			     mov al, [si + BORDER_HOR_PLAIN_OFFSET]
    535	02E1  8A 54 05 90			     mov dl, [si + BORDER_BR_CORNER_OFFSET]
    536
    537	02E5  E8 FFA1				     call draw_frame_line
    538
    539	02E8  C3				     ret
    540	02E9			     endp
    541
    542				     ;---------------------------------------------------------------
    543				     ; Displays	string.
    544				     ;
    545				     ; Entry: DS:SI - source string
    546				     ;	      ES:DI - dest address in video memory
    547				     ; Note:  ES - videoseg addr
    548				     ; Exit:  none
    549				     ; Chngs: none
    550				     ;---------------------------------------------------------------
    551	02E9			     display_string proc
    552	02E9			     @@copy_loop:
    553	02E9  AC				     lodsb
    554	02EA  84 C0				     test al, al
    555	02EC  74 03				     jz	@@copy_loop_end
    556
    557	02EE  AB				     stosw
    558	02EF  EB F8				     jmp @@copy_loop
    559	02F1			     @@copy_loop_end:
    560
    561	02F1  C3				     ret
    562	02F2			     endp
    563
    564				     ;---------------------------------------------------------------
    565				     ; Pad number so that it has the specified length.
    566				     ;
    567				     ; Entry: DS:SI - address of the string
    568				     ; Note:  none
    569				     ; Exit:  SI - new start of	the string
    570				     ; Chngs: SI
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 11
04resi~2.asm



    571				     ;---------------------------------------------------------------
    572	02F2			     pad_number	proc
    573	02F2  FC				     cld
    574
    575	02F3  51				     push cx
    576	02F4  06				     push es
    577	02F5  50				     push ax
    578
    579	02F6  8C D8				     mov ax, ds
    580	02F8  8E C0				     mov es, ax
    581
    582	02FA  58				     pop ax
    583
    584	02FB  87 F7				     xchg si, di
    585
    586						     ;--------------------------------------------------------------------
    587						     ; Returns length of a null	terminated string.
    588						     ;
    589						     ; Entry: ES:DI - address of the start of the string
    590						     ; Note:  max string length	is 65535.
    591						     ; Exit:  AL = 0
    592						     ;	      CX - length of the string
    593						     ;	      DI - next	byte after the zero byte of the	string
    594						     ; Chngs: AL CX DI
    595						     ;--------------------------------------------------------------------
    596	02FD  57				     push di
    597	02FE  E8 FE1A				     call strlen
    598	0301  5F				     pop di
    599
    600	0302  87 F7				     xchg si, di
    601
    602	0304  07				     pop es
    603
    604	0305  83 F1 FF				     xor cx, 0FFFFh
    605	0308  83 C1 01				     add cx, 1
    606
    607	030B  83 C1 04				     add cx, 4
    608
    609	030E  2B F1				     sub si, cx
    610
    611	0310  59				     pop cx
    612
    613	0311  C3				     ret
    614	0312			     endp
    615
    616				     ;---------------------------------------------------------------
    617				     ; Draw labels.
    618				     ;
    619				     ; Entry: none
    620				     ; Note:  none
    621				     ; Exit:  none
    622				     ; Chngs: none
    623				     ;---------------------------------------------------------------
    624	0312			     draw_labels proc
    625	0312  FC				     cld
    626
    627	0313  50				     push ax
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 12
04resi~2.asm



    628	0314  06				     push es
    629	0315  56				     push si
    630	0316  51				     push cx
    631	0317  57				     push di
    632
    633	0318  BF 00A4				     mov di, (SCREEN_COLS * 2 +	(1 + 1)	* 2)
    634	031B  89 3E 034Ar			     mov @@cur_line_start, di
    635	031F  33 C9				     xor cx, cx
    636
    637	0321  B8 B800				     mov ax, VIDEO_SEG
    638	0324  8E C0				     mov es, ax
    639
    640	0326  B4 07				     mov ah, 7h
    641	0328  BE 049Br				     mov si, offset registers
    642
    643	032B			     @@loop:
    644	032B  83 F9 08 90			     cmp cx, NUM_REGISTERS
    645	032F  74 13				     je	@@loop_end
    646
    647	0331  AC				     lodsb
    648	0332  AB				     stosw
    649
    650	0333  AC				     lodsb
    651	0334  AB				     stosw
    652
    653	0335  8B 3E 034Ar			     mov di, @@cur_line_start
    654	0339  81 C7 00A0			     add di, SCREEN_COLS * 2
    655	033D  89 3E 034Ar			     mov @@cur_line_start, di
    656
    657
    658	0341  41				     inc cx
    659	0342  EB E7				     jmp @@loop
    660
    661	0344			     @@loop_end:
    662	0344  5F				     pop di
    663	0345  59				     pop cx
    664	0346  5E				     pop si
    665	0347  07				     pop es
    666	0348  58				     pop ax
    667
    668	0349  C3				     ret
    669
    670	034A  0000		     @@cur_line_start dw 0
    671	034C			     endp
    672
    673
    674				     ;---------------------------------------------------------------
    675				     ; Draws register values.
    676				     ;
    677				     ; Entry: none
    678				     ; Note:  none
    679				     ; Exit:  none
    680				     ; Chngs: AX CX DI ES DF
    681				     ;---------------------------------------------------------------
    682	034C			     draw_values proc
    683	034C  FC				     cld
    684
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 13
04resi~2.asm



    685	034D  BF 00AA				     mov di, (SCREEN_COLS * 2 +	(1 + 1 + 2 + 1)	* 2)
    686	0350  89 3E 0397r			     mov @@cur_line_start, di
    687	0354  33 C9				     xor cx, cx
    688
    689	0356			     @@loop:
    690	0356  83 F9 08 90			     cmp cx, NUM_REGISTERS
    691	035A  74 3A				     je	@@loop_end
    692
    693	035C  51				     push cx			      ;	TODO: TRY to avoid.
    694	035D  57				     push di
    695
    696	035E  8B F1				     mov si, cx
    697	0360  D1 E6				     shl si, 1
    698	0362  8B 84 048Br			     mov ax, register_table[si]
    699	0366  D1 EE				     shr si, 1
    700	0368  BB 0010				     mov bx, 16
    701	036B  8C DF				     mov di, ds
    702	036D  8E C7				     mov es, di
    703	036F  BF 039Dr				     mov di, offset @@number_as_str
    704	0372  E8 FE0E				     call itoa
    705
    706	0375  5F				     pop di
    707	0376  59				     pop cx
    708
    709	0377  B8 B800				     mov ax, VIDEO_SEG
    710	037A  8E C0				     mov es, ax
    711
    712	037C  B4 07				     mov ah, 7h
    713	037E  BE 039Dr				     mov si, offset @@number_as_str
    714
    715	0381  E8 FF6E				     call pad_number			; SI = padded number
    716
    717	0384  E8 FF62				     call display_string
    718
    719	0387  8B 3E 0397r			     mov di, @@cur_line_start
    720	038B  81 C7 00A0			     add di, SCREEN_COLS * 2
    721	038F  89 3E 0397r			     mov @@cur_line_start, di
    722
    723
    724	0393  41				     inc cx
    725	0394  EB C0				     jmp @@loop
    726
    727	0396			     @@loop_end:
    728	0396  C3				     ret
    729
    730	0397  0000		     @@cur_line_start dw 0
    731	0399  04*(30)		     @@number_padding db 4 dup ('0')
    732	039D  06*(00)		     @@number_as_str db	6 dup (0)
    733	03A3			     endp
    734
    735				     ;---------------------------------------------------------------
    736				     ; Draw information.
    737				     ;
    738				     ; Entry: none
    739				     ; Note:  none
    740				     ; Exit:  none
    741				     ; Chngs: AX BX CX DX SI DI	ES DS
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 14
04resi~2.asm



    742				     ;---------------------------------------------------------------
    743	03A3			     draw_info proc
    744	03A3  B8 B800				     mov ax, VIDEO_SEG
    745	03A6  8E C0				     mov es, ax
    746	03A8  E8 FEEE				     call draw_frame
    747
    748	03AB  E8 FF64				     call draw_labels
    749
    750	03AE  E8 FF9B				     call draw_values
    751
    752	03B1  C3				     ret
    753	03B2			     endp
    754
    755				     ;---------------------------------------------------------------
    756				     ; The new handler for interrupt 8.
    757				     ;
    758				     ; Entry: none
    759				     ; Note:  none
    760				     ; Exit:  none
    761				     ; Chngs: AX BX DX SI DI
    762				     ;---------------------------------------------------------------
    763	03B2			     int8_handler proc
    764	03B2  50 53 51 52 57 56	06+		     push ax bx	cx dx di si es ds
    765	      1E
    766	03BA  9C				     pushf
    767
    768	03BB  E8 FEA1				     call save_registers
    769
    770	03BE  50				     push ax
    771	03BF  8C C8				     mov ax, cs
    772	03C1  8E D8				     mov ds, ax
    773	03C3  58				     pop ax
    774
    775	03C4  E8 FFDC				     call draw_info
    776
    777	03C7  9D				     popf
    778	03C8  1F 07 5E 5F 5A 59	5B+		     pop ds es si di dx	cx bx ax
    779	      58
    780
    781						     ; iret
    782	03D0  EA				     db	0EAh					 ; JMP FAR
    783	03D1  02*(0000)		     int8_jmp_far_arg dw 2 dup(0)
    784	03D5			     endp
    785
    786				     ;---------------------------------------------------------------
    787				     ; The new handler for interrupt 9.
    788				     ;
    789				     ; Entry: none
    790				     ; Note:  none
    791				     ; Exit:  none
    792				     ; Chngs: AX BX DX SI DI
    793				     ;---------------------------------------------------------------
    794				     ; F1+Z ---	выйти, F1+X --- показать/скрыть, F1+Space ---		    +
    795				     переключить стиль.
    796	03D5			     int9_handler proc
    797	03D5  50 57 1E 53			     push ax di	ds bx
    798
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 15
04resi~2.asm



    799	03D9  8C C8				     mov ax, cs
    800	03DB  8E D8				     mov ds, ax
    801
    802	03DD  E4 60				     in	al, 60h
    803
    804	03DF  8A E0				     mov ah, al
    805	03E1  B3 80 90 90			     mov bl, KEY_RELEASED_MASK
    806	03E5  22 E3				     and ah, bl
    807
    808	03E7  B3 7F				     mov bl, (KEY_RELEASED_MASK	xor 0FFFFh)    ; store inversed	bits of	the mask
    809	03E9  22 C3				     and al, bl
    810
    811	03EB  3C 3B 90 90			     cmp al, F1_SCAN_CODE
    812	03EF  74 13				     je	@@process_f1
    813
    814	03F1  3C 2C 90 90			     cmp al, Z_SCAN_CODE
    815	03F5  74 25				     je	@@process_z
    816
    817	03F7  3C 2D 90 90			     cmp al, X_SCAN_CODE
    818						     ; je @@process_x
    819
    820	03FB  3C 39 90 90			     cmp al, SPACE_SCAN_CODE
    821	03FF  74 4B				     je	@@process_space
    822
    823	0401  EB 7B 90				     jmp @@pass_to_prev_int9
    824
    825	0404			     @@process_f1:
    826	0404  84 E4				     test ah, ah
    827	0406  74 02				     jz	@@f1_pressed
    828	0408  75 09				     jnz @@f1_released
    829
    830	040A			     @@f1_pressed:
    831	040A  C6 06 0487r 01 90			     mov f1_pressed, 1
    832	0410  EB 57 90				     jmp @@consume_key
    833
    834	0413			     @@f1_released:
    835	0413  C6 06 0487r 00 90			     mov f1_pressed, 0
    836	0419  EB 4E 90				     jmp @@consume_key
    837
    838	041C			     @@process_z:
    839	041C  84 E4				     test ah, ah
    840	041E  75 49				     jnz @@consume_key		 ; Process only	key press, not key release.
    841
    842	0420  A0 0487r				     mov al, f1_pressed
    843	0423  84 C0				     test al, al
    844	0425  74 57				     jz	@@pass_to_prev_int9
    845
    846	0427  06				     push es
    847
    848	0428  BB 0009				     mov bx, 9
    849	042B  BF 0483r				     mov di, offset int9_jmp_far_arg
    850	042E  E8 FE18				     call restore_int
    851
    852	0431  BB 0008				     mov bx, 8
    853	0434  BF 03D1r				     mov di, offset int8_jmp_far_arg
    854	0437  E8 FE0F				     call restore_int
    855
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 16
04resi~2.asm



    856	043A  07				     pop es
    857
    858						     ; TODO: restore old picture.
    859
    860	043B  EB 2C 90				     jmp @@consume_key
    861
    862	043E			     @@process_x:
    863	043E  84 E4				     test ah, ah
    864	0440  75 27				     jnz @@consume_key		 ; Process only	key press, not key release.
    865
    866	0442  A0 0487r				     mov al, f1_pressed
    867	0445  84 C0				     test al, al
    868	0447  74 20				     jz	@@consume_key
    869	0449  EB 33 90				     jmp @@pass_to_prev_int9
    870
    871	044C			     @@process_space:
    872	044C  84 E4				     test ah, ah
    873	044E  75 19				     jnz @@consume_key		 ; Process only	key press, not key release.
    874
    875	0450  A0 0487r				     mov al, f1_pressed
    876	0453  84 C0				     test al, al
    877	0455  74 27				     jz	@@pass_to_prev_int9
    878
    879	0457  A1 04BDr				     mov ax, current_frame_style
    880	045A  05 0006 90			     add ax, STYLE_ENTRY_SIZE
    881	045E  3D 04BDr				     cmp ax, offset style_table_end
    882	0461  75 03				     jne @@skip_cycling_style
    883
    884	0463  B8 04ABr				     mov ax, offset style_table
    885	0466			     @@skip_cycling_style:
    886
    887	0466  A3 04BDr				     mov current_frame_style, ax
    888
    889	0469			     @@consume_key:
    890						     ; Такой код неприлично писать без		    +
    891				     комментариев. Нужны комментарии.
    892						     ; Если	scan код наш, то нужно будет говорить	с  +
    893				     клавиатурой и с контроллером прерываний, не прыгать+
    894				     на предыдущий обработчик.
    895	0469  E4 61				     in	al, 61h			 ; Send	ACK to kbd
    896	046B  8A E0				     mov ah, al
    897	046D  0C 80				     or	al, 80h
    898	046F  E6 61				     out 61h, al
    899	0471  8A C4				     mov al, ah
    900	0473  E6 61				     out 61h, al
    901
    902	0475  B0 20				     mov al, 20h		 ; Send	EOI to int cntrlr
    903	0477  E6 20				     out 20h, al
    904
    905	0479  5B 1F 5F 58			     pop bx ds di ax
    906	047D  CF				     iret
    907
    908	047E			     @@pass_to_prev_int9:
    909	047E  5B 1F 5F 58			     pop bx ds di ax
    910
    911	0482  EA				     db	JMP_FAR_OPCODE
    912	0483  02*(0000)		     int9_jmp_far_arg dw 2 dup(0)
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 17
04resi~2.asm



    913	0487			     endp
    914
    915	      =00EA		     JMP_FAR_OPCODE = 0eah
    916
    917	      =B800		     VIDEO_SEG = 0b800h
    918
    919	0487  00		     f1_pressed	db 0
    920	0488  00		     z_pressed db 0
    921	0489  00		     x_pressed db 0
    922	048A  00		     space_pressed db 0
    923
    924	      =0080		     KEY_RELEASED_MASK = 80h
    925
    926	      =003B		     F1_SCAN_CODE = 3bh
    927	      =002C		     Z_SCAN_CODE = 2ch
    928	      =002D		     X_SCAN_CODE = 2dh
    929	      =0039		     SPACE_SCAN_CODE = 39h
    930
    931				     ; ax, bx, cx, dx, si, di, es, ds, fs, gs
    932	      =0008		     NUM_REGISTERS = 8d
    933	048B  08*(0000)		     register_table dw NUM_REGISTERS dup(0)
    934	049B  61 78 62 78 63 78	64+  registers db "ax",	"bx", "cx", "dx", "si",	"di", "ds", "es"
    935	      78 73 69 64 69 64	73+
    936	      65 73
    937
    938	      =0002		     REGISTER_LENGTH = 2
    939	      =0004		     VALUE_LENGTH = 4
    940	      =000B		     FRAME_COLS	= 1 + 1	+ REGISTER_LENGTH + 1 +	VALUE_LENGTH + 1 + 1
    941	      =000A		     FRAME_ROWS	= 1 + NUM_REGISTERS + 1
    942	      =0050		     SCREEN_COLS = 80
    943
    944	      =0000		     BORDER_VERT_PLAIN_OFFSET =	0d
    945	      =0001		     BORDER_HOR_PLAIN_OFFSET  =	1d
    946	      =0002		     BORDER_TL_CORNER_OFFSET  =	2d
    947	      =0003		     BORDER_TR_CORNER_OFFSET  =	3d
    948	      =0004		     BORDER_BL_CORNER_OFFSET  =	4d
    949	      =0005		     BORDER_BR_CORNER_OFFSET  =	5d
    950
    951	04AB			     style_table:
    952	      =0006		     STYLE_ENTRY_SIZE =	1d * 6d
    953				     ; vertical	plain border, horizonal	plain border, top left corner, top right corner, bottom	left+
    954				     corner, bottom right
    955				     ; user_frame	 db 0,	     0,	   0,	 0,    0,     0
    956	04AB  B3 C4 DA BF C0 D9	     single_line_frame db 0b3h,	0c4h, 0dah, 0bfh, 0c0h,	 0d9h
    957	04B1  BA CD C9 BB C8 BC	     double_line_frame db 0bah,	0cdh, 0c9h, 0bbh, 0c8h,	 0bch
    958	04B7  B3 C4 C5 C5 C5 C5	     plus_frame	       db 0b3h,	0c4h, 0c5h, 0c5h, 0c5h,	 0c5h
    959	04BD			     style_table_end:
    960
    961				     ; address of the table entry for the current style
    962	04BD  04ABr		     current_frame_style dw offset style_table
    963
    964	04BF			     end_of_program:
    965				     end start
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 18
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "03/25/22"
??FILENAME			  Text	 "04resi~2"
??TIME				  Text	 "20:34:48"
??VERSION			  Number 040A
@32BIT				  Text	 0
@@CHAR_TABLE			  Byte	 DGROUP:01E1
@@CONSUME_KEY			  Near	 DGROUP:0469
@@COPY_LOOP			  Near	 DGROUP:02E9
@@COPY_LOOP_END			  Near	 DGROUP:02F1
@@CUR_LINE_START		  Word	 DGROUP:034A
@@CUR_LINE_START		  Word	 DGROUP:0397
@@DO_COPY			  Near	 DGROUP:0170
@@F1_PRESSED			  Near	 DGROUP:040A
@@F1_RELEASED			  Near	 DGROUP:0413
@@FILL_WITH_ZEROS		  Near	 DGROUP:015A
@@GENERAL_BASE_LOOP		  Near	 DGROUP:0190
@@LIMIT_OUTPUT			  Near	 DGROUP:016B
@@LOOP				  Near	 DGROUP:0207
@@LOOP				  Near	 DGROUP:02C3
@@LOOP				  Near	 DGROUP:032B
@@LOOP				  Near	 DGROUP:0356
@@LOOP_END			  Near	 DGROUP:01CC
@@LOOP_END			  Near	 DGROUP:021D
@@LOOP_END			  Near	 DGROUP:02D1
@@LOOP_END			  Near	 DGROUP:0344
@@LOOP_END			  Near	 DGROUP:0396
@@NOT_FOUND			  Near	 DGROUP:013F
@@NUMBER_AS_STR			  Byte	 DGROUP:039D
@@NUMBER_IS_ZERO		  Near	 DGROUP:01D8
@@NUMBER_PADDING		  Byte	 DGROUP:0399
@@PASS_TO_PREV_INT9		  Near	 DGROUP:047E
@@POWER_CALCULATED		  Near	 DGROUP:01B3
@@POWER_LOOP			  Near	 DGROUP:01A8
@@POWER_OF_2			  Near	 DGROUP:01A6
@@POWER_OF_2_LOOP		  Near	 DGROUP:01B6
@@PROCESS_F1			  Near	 DGROUP:0404
@@PROCESS_SPACE			  Near	 DGROUP:044C
@@PROCESS_X			  Near	 DGROUP:043E
@@PROCESS_Z			  Near	 DGROUP:041C
@@SKIP_CYCLING_STYLE		  Near	 DGROUP:0466
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0103H
@CURSEG				  Text	 _TEXT
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 04RESI~2
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
ATOI				  Near	 DGROUP:021F
BORDER_BL_CORNER_OFFSET		  Number 0004
BORDER_BR_CORNER_OFFSET		  Number 0005
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 19
Symbol Table



BORDER_HOR_PLAIN_OFFSET		  Number 0001
BORDER_TL_CORNER_OFFSET		  Number 0002
BORDER_TR_CORNER_OFFSET		  Number 0003
BORDER_VERT_PLAIN_OFFSET	  Number 0000
CURRENT_FRAME_STYLE		  Word	 DGROUP:04BD
DISPLAY_STRING			  Near	 DGROUP:02E9
DOUBLE_LINE_FRAME		  Byte	 DGROUP:04B1
DRAW_FRAME			  Near	 DGROUP:0299
DRAW_FRAME_LINE			  Near	 DGROUP:0289
DRAW_INFO			  Near	 DGROUP:03A3
DRAW_LABELS			  Near	 DGROUP:0312
DRAW_VALUES			  Near	 DGROUP:034C
END_OF_PROGRAM			  Near	 DGROUP:04BF
F1_PRESSED			  Byte	 DGROUP:0487
F1_SCAN_CODE			  Number 003B
FRAME_COLS			  Number 000B
FRAME_ROWS			  Number 000A
GO_RESIDENT			  Near	 DGROUP:021F
INT8_HANDLER			  Near	 DGROUP:03B2
INT8_JMP_FAR_ARG		  Word	 DGROUP:03D1
INT9_HANDLER			  Near	 DGROUP:03D5
INT9_JMP_FAR_ARG		  Word	 DGROUP:0483
ITOA				  Near	 DGROUP:0183
JMP_FAR_OPCODE			  Number 00EA
KEY_RELEASED_MASK		  Number 0080
NUM_REGISTERS			  Number 0008
PAD_NUMBER			  Near	 DGROUP:02F2
PLUS_FRAME			  Byte	 DGROUP:04B7
REGISTERS			  Byte	 DGROUP:049B
REGISTER_LENGTH			  Number 0002
REGISTER_TABLE			  Word	 DGROUP:048B
RESTORE_INT			  Near	 DGROUP:0249
REVERSE_STRING			  Near	 DGROUP:0205
SAVE_REGISTERS			  Near	 DGROUP:025F
SCREEN_COLS			  Number 0050
SET_INT				  Near	 DGROUP:022C
SINGLE_LINE_FRAME		  Byte	 DGROUP:04AB
SPACE_PRESSED			  Byte	 DGROUP:048A
SPACE_SCAN_CODE			  Number 0039
START				  Near	 DGROUP:0100
STRCHR				  Near	 DGROUP:0128
STRLEN				  Near	 DGROUP:011B
STRNCMP				  Near	 DGROUP:017D
STRNCPY				  Near	 DGROUP:0142
STYLE_ENTRY_SIZE		  Number 0006
STYLE_TABLE			  Near	 DGROUP:04AB
STYLE_TABLE_END			  Near	 DGROUP:04BD
VALUE_LENGTH			  Number 0004
VIDEO_SEG			  Number B800
X_PRESSED			  Byte	 DGROUP:0489
X_SCAN_CODE			  Number 002D
Z_PRESSED			  Byte	 DGROUP:0488
Z_SCAN_CODE			  Number 002C
Turbo Assembler	 Version 4.1	    03/25/22 20:34:49	    Page 20
Symbol Table




Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  0000 Word	  Public  DATA
  _TEXT				  16  04BF Word	  Public  CODE
