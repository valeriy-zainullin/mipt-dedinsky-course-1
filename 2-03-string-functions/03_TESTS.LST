Turbo Assembler	 Version 4.1	    03/13/22 11:31:28	    Page 1
03_tests.asm



      1	0000			     .model tiny
      2
      3	0000			     .code
      4				     org 100h
      5
      6				     locals
      7
      8	0100			     start:
      9	0100  8C D8				     mov ax, ds
     10	0102  8E C0				     mov es, ax
     11
     12	0104  A1 0000r				     mov ax, number
     13	0107  BB 0010				     mov bx, 16
     14	010A  BF 0002r				     mov di, offset number_as_string
     15
     16																    +
     17				     ;---------------------------------------------------------------------------------
     18						     ; Converts	integer	to ASCII string	in the specified base.
     19						     ;
     20						     ; Entry: AX - number to be	converted,
     21						     ;	      BX - base,
     22						     ;	      DS:SI - output string (must be sufficient	to hold	the number	    +
     23				     converted).
     24						     ; Note:  none.
     25						     ; Exit:  DS:SI - address of the zero byte of the string
     26						     ; Chngs: BX DX
     27																    +
     28				     ;---------------------------------------------------------------------------------
     29	010D  E8 006D				     call itoa
     30
     31	0110  B8 4C00				     mov ax, 4c00h			      ;	Выйти из	программы  +
     32				     и	передать управление DOSу
     33	0113  CD 21				     int 21h
     34
     35				     include 03.asm
1    36				     ﻿locals
1    37
1    38				     ;--------------------------------------------------------------------
1    39				     ; Returns length of a null	terminated string.
1    40				     ;
1    41				     ; Entry: ES:DI - address of the start of the string
1    42				     ; Note:  max string length	is 65535.
1    43				     ; Exit:  AL = 0
1    44				     ;	      CX - length of the string
1    45				     ;	      DI - next	byte after the zero byte of the	string
1    46				     ; Chngs: AL CX DI
1    47				     ;--------------------------------------------------------------------
1    48				     ; size_t strlen( const char * string );
1    49	0115			     strlen proc
1    50	0115  FC				     cld
1    51
1    52	0116  32 C0				     xor al, al
1    53	0118  B9 FFFF				     mov cx, 0ffffh
1    54	011B  F2> AE				     repne scasb	 ; After the instruction cx is 0xFFFF -	(number	of non zero +
     55				     symbols + 1).
1    56									 ; cx is decremeted first, then	comparison for cx = 0 or zf +
     57				     happens.
Turbo Assembler	 Version 4.1	    03/13/22 11:31:28	    Page 2
03_tests.asm



1    58									 ; after the zero byte cx is decremented as well.
1    59									 ; scasb after comparing zero byte will	increment di as	well.
1    60									 ; DI =	next byte after	the terminating	zero byte.
1    61	011D  83 F1 FF				     xor cx, 0ffffh	 ; CX =	~CX = 0xFFFF - cx = number of non zero symbols + 1
1    62	0120  49				     dec cx		 ; CX =	number of non zero symbols
1    63
1    64	0121  C3				     ret
1    65	0122			     endp
1    66
1    67				     ;--------------------------------------------------------------------
1    68				     ; Looks for character in a	null-terminated	string.
1    69				     ;
1    70				     ; Entry: ES:DI - address of the start of the string,
1    71				     ;	      AL    - character	to be found
1    72				     ; Note:  max string length	is 65535.
1    73				     ; Exit:  AH = 0,
1    74				     ;	      DI - address of the character found or zero
1    75				     ;	      CX - length - index of character - 1 (0-based) or	0 if not found
1    76				     ; Chngs: AX CX DI
1    77				     ;--------------------------------------------------------------------
1    78				     ; char * strchr( const char * string, int symbol);
1    79	0122			     strchr proc
1    80	0122  FC				     cld
1    81
1    82	0123  86 E0				     xchg ah, al
1    83	0125  E8 FFED				     call strlen
1    84	0128  86 E0				     xchg ah, al
1    85
1    86	012A  85 C9				     test cx, cx
1    87	012C  74 0B				     jz	@@not_found   ;	taken if length	is zero	to not feed it to rep**. It will    +
     88				     iterate over 0xFFFF + 1 items otherwise.
1    89
1    90						     ; DI = address of the byte	after the terminating zero.
1    91	012E  4F				     dec di
1    92	012F  2B F9				     sub di, cx
1    93						     ; CX = start of the string
1    94
1    95	0131  F2> AE				     repne scasb      ;	After comparing	the zero byte, di is still incremented.
1    96	0133  4F				     dec di	      ;	Decrement it back.
1    97
1    98	0134  85 C9				     test cx, cx
1    99	0136  74 01				     jz	@@not_found
1   100
1   101	0138  C3				     ret
1   102
1   103	0139			     @@not_found:
1   104	0139  33 FF				     xor di, di
1   105	013B  C3				     ret
1   106	013C			     endp
1   107
1   108				     ;--------------------------------------------------------------------
1   109				     ; Copies string to	a buffer. At most num bytes written to the buffer.
1   110				     ;
1   111				     ; Entry: ES:DI - destination address
1   112				     ;	      DS:SI - source address
1   113				     ;	      BX    - max number of bytes written for dest. address
1   114				     ; Note:  max string length	is 65535.
Turbo Assembler	 Version 4.1	    03/13/22 11:31:28	    Page 3
03_tests.asm



1   115				     ; Exit:   = 0,
1   116				     ;	      DI - address of the character found or zero
1   117				     ;	      CX - length - index of character - 1 (0-based)
1   118				     ; Chngs: AX BX CX SI DI
1   119				     ;--------------------------------------------------------------------
1   120				     ; char * strncpy( char * destptr, const char * srcptr, size_t num );
1   121				     ; Rethink.	May be broken as hell.
1   122	013C			     strncpy proc
1   123	013C  FC				     cld
1   124
1   125	013D  8C D8				     mov ax, ds
1   126	013F  8C C1				     mov cx, es
1   127	0141  8E D9				     mov ds, cx
1   128	0143  8E C0				     mov es, ax
1   129	0145  87 FE				     xchg di, si
1   130
1   131						     ;--------------------------------------------------------------------
1   132						     ; Returns length of a null	terminated string.
1   133						     ;
1   134						     ; Entry: ES:DI - address of the start of the string
1   135						     ; Note:  max string length	is 65535.
1   136						     ; Exit:  AL = 0
1   137						     ;	      CX - length of the string
1   138						     ;	      DI - next	byte after the zero byte of the	string
1   139						     ; Chngs: AL CX DI
1   140						     ;--------------------------------------------------------------------
1   141						     ; size_t strlen( const char * string );
1   142	0147  E8 FFCB				     call strlen
1   143	014A  41				     inc cx						 ; CX =	length + 1
1   144						     ; SI is at	the byte after the zero	byte.
1   145						     ; sub di, cx
1   146
1   147	014B  3B CB				     cmp cx, bx
1   148	014D  72 05				     jb	@@fill_with_zeros
1   149	014F  77 14				     ja	@@limit_output
1   150	0151  EB 17 90				     jmp @@do_copy
1   151
1   152	0154			     @@fill_with_zeros:
1   153	0154  2B D9				     sub bx, cx
1   154
1   155	0156  03 FB				     add di, bx
1   156	0158  87 D9				     xchg bx, cx
1   157	015A  FD				     std
1   158	015B  32 C0				     xor al, al
1   159	015D  F3> AA				     rep stosb
1   160	015F  FC				     cld
1   161
1   162	0160  87 D9				     xchg bx, cx
1   163
1   164						     ; DI is now shifted for -(1 + (BX - CX)) at the start of the string as before.
1   165
1   166	0162  EB 06 90				     jmp @@do_copy
1   167
1   168	0165			     @@limit_output:
1   169	0165  8B CB				     mov cx, bx
1   170	0167  EB 01 90				     jmp @@do_copy
1   171
Turbo Assembler	 Version 4.1	    03/13/22 11:31:28	    Page 4
03_tests.asm



1   172	016A			     @@do_copy:
1   173	016A  8C D8				     mov ax, ds
1   174	016C  8C C3				     mov bx, es
1   175	016E  8E DB				     mov ds, bx
1   176	0170  8E C0				     mov es, ax
1   177	0172  87 FE				     xchg di, si
1   178
1   179	0174  F3> A4				     rep movsb
1   180
1   181	0176  C3				     ret
1   182	0177			     endp
1   183
1   184				     ;--------------------------------------------------------------------
1   185				     ; Compares	two strings. Considers first n bytes.
1   186				     ;
1   187				     ; Entry: ES:DI - first string
1   188				     ;	      DS:SI - second string
1   189				     ;	      BX    - number of	bytes considered
1   190				     ; Note:  max string length	is 65535.
1   191				     ; Exit:   = 0,
1   192				     ; Chngs: AH CX DI
1   193				     ;--------------------------------------------------------------------
1   194				     ; int strncmp( const char * string1, const	char * string2,	size_t num );
1   195	0177			     strncmp proc
1   196	0177  FC				     cld
1   197
1   198	0178  E8 FF9A				     call strlen
1   199
1   200
1   201
1   202	017B  F3> A6				     repe cmpsb
1   203	017D			     endp
1   204
1   205				     ;---------------------------------------------------------------------------------
1   206				     ; Converts	integer	to ASCII string	in the specified base.
1   207				     ;
1   208				     ; Entry: AX - number to be	converted,
1   209				     ;	      BX - base,
1   210				     ;	      ES:DI - output string (must be sufficient	to hold	the number converted).
1   211				     ; Note:  none.
1   212				     ; Exit:  DS:DI - address of the zero byte of the string
1   213				     ; Chngs: BX DX
1   214				     ;---------------------------------------------------------------------------------
1   215				     ; void* itoa(int input, char *buffer, int radix)
1   216				     ; TODO: handle negative values.
1   217				     ; TODO: optimize a	little bit more.
1   218	017D			     itoa proc
1   219
1   220						     ; UB if base if less than 2 or greater than 36
1   221						     ; cmp bx, 2
1   222						     ; jl @@invalid_base
1   223						     ; cmp bx, 36
1   224						     ; jg @@invalid_base
1   225
1   226	017D  85 C0				     test ax, ax
1   227	017F  74 48				     jz	@@number_is_zero
1   228
Turbo Assembler	 Version 4.1	    03/13/22 11:31:28	    Page 5
03_tests.asm



1   229	0181  8B D3				     mov dx, bx
1   230	0183  4A				     dec dx
1   231	0184  85 D3				     test dx, bx
1   232
1   233	0186  74 16				     jz	@@power_of_2
1   234
1   235				     ; General base
1   236	0188			     @@general_base_loop:
1   237	0188  85 C0				     test ax, ax
1   238	018A  74 38				     jz	@@loop_end
1   239
1   240	018C  33 D2				     xor dx, dx
1   241	018E  F7 F3				     div bx
1   242
1   243	0190  8B F2				     mov si, dx
1   244	0192  32 F6				     xor dh, dh
1   245	0194  8A 94 01C9r			     mov dl, @@char_table[si * 1]
1   246
1   247	0198  26: 89 15				     mov es:[di], dx
1   248	019B  47				     inc di
1   249
1   250	019C  EB EA				     jmp @@general_base_loop
1   251
1   252	019E			     @@power_of_2:
1   253	019E  32 C9				     xor cl, cl
1   254	01A0			     @@power_loop:
1   255	01A0  83 FB 01				     cmp bx, 1
1   256	01A3  74 06				     je	@@power_calculated
1   257
1   258	01A5  FE C1				     inc cl
1   259	01A7  D1 EB				     shr bx, 1
1   260
1   261	01A9  EB F5				     jmp @@power_loop
1   262	01AB			     @@power_calculated:
1   263
1   264	01AB  D3 E3				     shl bx, cl
1   265	01AD  4B				     dec bx
1   266	01AE			     @@power_of_2_loop:
1   267	01AE  85 C0				     test ax, ax
1   268	01B0  74 12				     jz	@@loop_end
1   269
1   270	01B2  8B F0				     mov si, ax
1   271	01B4  23 F3				     and si, bx
1   272	01B6  32 F6				     xor dh, dh
1   273	01B8  8A 94 01C9r			     mov dl, @@char_table[si * 1]
1   274
1   275	01BC  26: 89 15				     mov es:[di], dx
1   276	01BF  47				     inc di
1   277
1   278	01C0  D3 E8				     shr ax, cl
1   279	01C2  EB EA				     jmp @@power_of_2_loop
1   280
1   281	01C4			     @@loop_end:
1   282
1   283	01C4  26: C6 05	00			     mov byte ptr es:[di], 0
1   284
1   285						     ; TODO: reverse string.
Turbo Assembler	 Version 4.1	    03/13/22 11:31:28	    Page 6
03_tests.asm



1   286
1   287	01C8  C3				     ret
1   288
1   289	01C9			     @@number_is_zero:
1   290
1   291
1   292				     ;@@invalid_base:
1   293				     ;		     ret
1   294
1   295	01C9  30 31 32 33 34 35	36+  @@char_table db '0', '1', '2', '3', '4', '5', '6',	'7', '8', '9'
    296	      37 38 39
1   297	01D3  41 42 43 44 45 46	47+		  db 'A', 'B', 'C', 'D', 'E', 'F', 'G',	'H', 'I', 'J'
    298	      48 49 4A
1   299	01DD  4B 4C 4D 4E 4F 50	51+		  db 'K', 'L', 'M', 'N', 'O', 'P', 'Q',	'R', 'S', 'T'
    300	      52 53 54
1   301	01E7  55 56 57 58 59 5A			  db 'U', 'V', 'W', 'X', 'Y', 'Z'
1   302
1   303	01ED			     endp
1   304
1   305	01ED			     reverse_string proc
1   306	01ED			     endp
1   307
1   308				     ;---------------------------------------------------------------------------------
1   309				     ; Converts	ASCII string in	base 10	to string.
1   310				     ;
1   311				     ; Entry: AX - number to be	converted,
1   312				     ;	      BX - base,
1   313				     ;	      DS:SI - output string (must be sufficient	to hold	the number converted).
1   314				     ; Note:  none.
1   315				     ; Exit:  DS:SI - address of the zero byte of the string
1   316				     ; Chngs: BX DX
1   317				     ;---------------------------------------------------------------------------------
1   318				     ; void* itoa(int input, char *buffer, int radix)
1   319	01ED			     atoi proc
1   320	01ED			     endp
1   321
    322	01ED			     endp
    323
    324	01ED			     .data
    325
    326	0000  3039		     number dw 12345
    327	0002  61 62 63 65 66 67	68+  number_as_string db "abcefghijklmnopqrstuvxyz", 0
    328	      69 6A 6B 6C 6D 6E	6F+
    329	      70 71 72 73 74 75	76+
    330	      78 79 7A 00
    331
    332				     ; size_t strlen( const char * string );
    333				     ; char * strchr( const char * string, int symbol);
    334				     ; char * strncpy( char * destptr, const char * srcptr, size_t num );
    335				     ; int strncmp( const char * string1, const	char * string2,	size_t num );
    336				     ; char *itoa( int value, char * string, int radix );
    337				     ; int atoi( const char * string );
    338
    339				     ; strlen, strchr, strncpy,	strncmp, itoa, atoi, printf
    340
    341				     end start
Turbo Assembler	 Version 4.1	    03/13/22 11:31:28	    Page 7
Symbol Table




Symbol Name			  Type	 Value

??DATE				  Text	 "03/13/22"
??FILENAME			  Text	 "03_tests"
??TIME				  Text	 "11:31:28"
??VERSION			  Number 040A
@32BIT				  Text	 0
@@CHAR_TABLE			  Byte	 DGROUP:01C9
@@DO_COPY			  Near	 DGROUP:016A
@@FILL_WITH_ZEROS		  Near	 DGROUP:0154
@@GENERAL_BASE_LOOP		  Near	 DGROUP:0188
@@LIMIT_OUTPUT			  Near	 DGROUP:0165
@@LOOP_END			  Near	 DGROUP:01C4
@@NOT_FOUND			  Near	 DGROUP:0139
@@NUMBER_IS_ZERO		  Near	 DGROUP:01C9
@@POWER_CALCULATED		  Near	 DGROUP:01AB
@@POWER_LOOP			  Near	 DGROUP:01A0
@@POWER_OF_2			  Near	 DGROUP:019E
@@POWER_OF_2_LOOP		  Near	 DGROUP:01AE
@CODE				  Text	 DGROUP
@CODESIZE			  Text	 0
@CPU				  Text	 0101H
@CURSEG				  Text	 _DATA
@DATA				  Text	 DGROUP
@DATASIZE			  Text	 0
@FILENAME			  Text	 03_TESTS
@INTERFACE			  Text	 000H
@MODEL				  Text	 1
@STACK				  Text	 DGROUP
@WORDSIZE			  Text	 2
ATOI				  Near	 DGROUP:01ED
ITOA				  Near	 DGROUP:017D
NUMBER				  Word	 DGROUP:0000
NUMBER_AS_STRING		  Byte	 DGROUP:0002
REVERSE_STRING			  Near	 DGROUP:01ED
START				  Near	 DGROUP:0100
STRCHR				  Near	 DGROUP:0122
STRLEN				  Near	 DGROUP:0115
STRNCMP				  Near	 DGROUP:0177
STRNCPY				  Near	 DGROUP:013C

Groups & Segments		  Bit Size Align  Combine Class

DGROUP				  Group
  _DATA				  16  001B Word	  Public  DATA
  _TEXT				  16  01ED Word	  Public  CODE
